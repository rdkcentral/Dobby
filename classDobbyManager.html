<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dobby: DobbyManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dobby
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">Dobby “Docker based Thingy” is a tool for managing and running OCI containers using crun</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDobbyManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DobbyManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The main object which starts / stops / manages the containers.  
 <a href="classDobbyManager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DobbyManager_8h_source.html">DobbyManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a98e1ca669cd3eca740252b479e2775d4"><td class="memItemLeft" align="right" valign="top"><a id="a98e1ca669cd3eca740252b479e2775d4"></a>
typedef std::function&lt; void(int32_t cd, const <a class="el" href="classContainerId.html">ContainerId</a> &amp;id)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ContainerStartedFunc</b></td></tr>
<tr class="separator:a98e1ca669cd3eca740252b479e2775d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af578985ac1c6d98cf32df821a77c258f"><td class="memItemLeft" align="right" valign="top"><a id="af578985ac1c6d98cf32df821a77c258f"></a>
typedef std::function&lt; void(int32_t cd, const <a class="el" href="classContainerId.html">ContainerId</a> &amp;id, int32_t status)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ContainerStoppedFunc</b></td></tr>
<tr class="separator:af578985ac1c6d98cf32df821a77c258f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65318e37c6367e6c676007dbcfec3ea4"><td class="memItemLeft" align="right" valign="top"><a id="a65318e37c6367e6c676007dbcfec3ea4"></a>
typedef std::function&lt; void(int32_t cd, const <a class="el" href="classContainerId.html">ContainerId</a> &amp;id)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ContainerHibernatedFunc</b></td></tr>
<tr class="separator:a65318e37c6367e6c676007dbcfec3ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a15da48d127df6934fcb8903281b4e37d"><td class="memItemLeft" align="right" valign="top"><a id="a15da48d127df6934fcb8903281b4e37d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DobbyManager</b> (const std::shared_ptr&lt; <a class="el" href="classIDobbyEnv.html">IDobbyEnv</a> &gt; &amp;env, const std::shared_ptr&lt; <a class="el" href="classIDobbyUtils__v3.html">IDobbyUtils</a> &gt; &amp;utils, const std::shared_ptr&lt; <a class="el" href="classIDobbyIPCUtils.html">IDobbyIPCUtils</a> &gt; &amp;ipcUtils, const std::shared_ptr&lt; const <a class="el" href="classIDobbySettings.html">IDobbySettings</a> &gt; &amp;settings, const ContainerStartedFunc &amp;containerStartedCb, const ContainerStoppedFunc &amp;containerStoppedCb, const ContainerHibernatedFunc &amp;containerHibernatedCb, const ContainerHibernatedFunc &amp;containerAwokenCb)</td></tr>
<tr class="separator:a15da48d127df6934fcb8903281b4e37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e3c66c1edf14b1f292fb28004968d3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a66e3c66c1edf14b1f292fb28004968d3">startContainerFromBundle</a> (const <a class="el" href="classContainerId.html">ContainerId</a> &amp;id, const std::string &amp;bundlePath, const std::list&lt; int &gt; &amp;files, const std::string &amp;command, const std::string &amp;displaySocket, const std::vector&lt; std::string &gt; &amp;envVars)</td></tr>
<tr class="memdesc:a66e3c66c1edf14b1f292fb28004968d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where the magic begins ... attempts to create a container from an OCI bundle*.  <a href="classDobbyManager.html#a66e3c66c1edf14b1f292fb28004968d3">More...</a><br /></td></tr>
<tr class="separator:a66e3c66c1edf14b1f292fb28004968d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc24032118b91fc1660ae4be7dedaf2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#abc24032118b91fc1660ae4be7dedaf2f">stopContainer</a> (int32_t cd, bool withPrejudice)</td></tr>
<tr class="memdesc:abc24032118b91fc1660ae4be7dedaf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops a running container.  <a href="classDobbyManager.html#abc24032118b91fc1660ae4be7dedaf2f">More...</a><br /></td></tr>
<tr class="separator:abc24032118b91fc1660ae4be7dedaf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68bb880628681639726ce3e0d48067d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#ae68bb880628681639726ce3e0d48067d">pauseContainer</a> (int32_t cd)</td></tr>
<tr class="memdesc:ae68bb880628681639726ce3e0d48067d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freezes a running container.  <a href="classDobbyManager.html#ae68bb880628681639726ce3e0d48067d">More...</a><br /></td></tr>
<tr class="separator:ae68bb880628681639726ce3e0d48067d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4e604d228f20045b2a4624d0295a30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a2d4e604d228f20045b2a4624d0295a30">resumeContainer</a> (int32_t cd)</td></tr>
<tr class="memdesc:a2d4e604d228f20045b2a4624d0295a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thaws a frozen container.  <a href="classDobbyManager.html#a2d4e604d228f20045b2a4624d0295a30">More...</a><br /></td></tr>
<tr class="separator:a2d4e604d228f20045b2a4624d0295a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac201b6ea9cc3aaae0c23b0dd13fc2ecc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#ac201b6ea9cc3aaae0c23b0dd13fc2ecc">hibernateContainer</a> (int32_t cd, const std::string &amp;options)</td></tr>
<tr class="memdesc:ac201b6ea9cc3aaae0c23b0dd13fc2ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a running container's processes.  <a href="classDobbyManager.html#ac201b6ea9cc3aaae0c23b0dd13fc2ecc">More...</a><br /></td></tr>
<tr class="separator:ac201b6ea9cc3aaae0c23b0dd13fc2ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c23b8b21675ad8f377b62823a2fd46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a61c23b8b21675ad8f377b62823a2fd46">wakeupContainer</a> (int32_t cd)</td></tr>
<tr class="memdesc:a61c23b8b21675ad8f377b62823a2fd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakeup a checkpointed container from existing dump.  <a href="classDobbyManager.html#a61c23b8b21675ad8f377b62823a2fd46">More...</a><br /></td></tr>
<tr class="separator:a61c23b8b21675ad8f377b62823a2fd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51074edde8c775e771f9420d948752ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a51074edde8c775e771f9420d948752ea">addMount</a> (int32_t cd, const std::string &amp;source, const std::string &amp;destination, const std::vector&lt; std::string &gt; &amp;mountFlags, const std::string &amp;mountData)</td></tr>
<tr class="memdesc:a51074edde8c775e771f9420d948752ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a mount to a running container  <a href="classDobbyManager.html#a51074edde8c775e771f9420d948752ea">More...</a><br /></td></tr>
<tr class="separator:a51074edde8c775e771f9420d948752ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3582f066e8fea7425e4bbd26da194c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a7a3582f066e8fea7425e4bbd26da194c">removeMount</a> (int32_t cd, const std::string &amp;source)</td></tr>
<tr class="memdesc:a7a3582f066e8fea7425e4bbd26da194c"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes a mount from a running container  <a href="classDobbyManager.html#a7a3582f066e8fea7425e4bbd26da194c">More...</a><br /></td></tr>
<tr class="separator:a7a3582f066e8fea7425e4bbd26da194c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f396a3d1f2f145aa05ff23bfc50685"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a26f396a3d1f2f145aa05ff23bfc50685">execInContainer</a> (int32_t cd, const std::string &amp;options, const std::string &amp;command)</td></tr>
<tr class="memdesc:a26f396a3d1f2f145aa05ff23bfc50685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a command in a running container.  <a href="classDobbyManager.html#a26f396a3d1f2f145aa05ff23bfc50685">More...</a><br /></td></tr>
<tr class="separator:a26f396a3d1f2f145aa05ff23bfc50685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916432f3341a3eeae5de5e06807374e3"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::pair&lt; int32_t, <a class="el" href="classContainerId.html">ContainerId</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a916432f3341a3eeae5de5e06807374e3">listContainers</a> () const</td></tr>
<tr class="memdesc:a916432f3341a3eeae5de5e06807374e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all the containers.  <a href="classDobbyManager.html#a916432f3341a3eeae5de5e06807374e3">More...</a><br /></td></tr>
<tr class="separator:a916432f3341a3eeae5de5e06807374e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abceecde3a6a164e13f3799a5dd4a3636"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#abceecde3a6a164e13f3799a5dd4a3636">stateOfContainer</a> (int32_t cd) const</td></tr>
<tr class="memdesc:abceecde3a6a164e13f3799a5dd4a3636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the state of a given container.  <a href="classDobbyManager.html#abceecde3a6a164e13f3799a5dd4a3636">More...</a><br /></td></tr>
<tr class="separator:abceecde3a6a164e13f3799a5dd4a3636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50849443ccba22c698d223234125471b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a50849443ccba22c698d223234125471b">statsOfContainer</a> (int32_t cd) const</td></tr>
<tr class="memdesc:a50849443ccba22c698d223234125471b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the stats for the container.  <a href="classDobbyManager.html#a50849443ccba22c698d223234125471b">More...</a><br /></td></tr>
<tr class="separator:a50849443ccba22c698d223234125471b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab07082f515abc77f157954747cad11"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a7ab07082f515abc77f157954747cad11">ociConfigOfContainer</a> (int32_t cd) const</td></tr>
<tr class="memdesc:a7ab07082f515abc77f157954747cad11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging method to allow you to retrieve the OCI config.json spec used to create the container.  <a href="classDobbyManager.html#a7ab07082f515abc77f157954747cad11">More...</a><br /></td></tr>
<tr class="separator:a7ab07082f515abc77f157954747cad11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a856645daacea432a97c72d88411f33cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a856645daacea432a97c72d88411f33cd">setupSystem</a> ()</td></tr>
<tr class="memdesc:a856645daacea432a97c72d88411f33cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the linux system for enabling features needed for runc.  <a href="classDobbyManager.html#a856645daacea432a97c72d88411f33cd">More...</a><br /></td></tr>
<tr class="separator:a856645daacea432a97c72d88411f33cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918da197e28becc45718ec9b93076cf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a918da197e28becc45718ec9b93076cf8">setupWorkspace</a> (const std::shared_ptr&lt; <a class="el" href="classIDobbyEnv.html">IDobbyEnv</a> &gt; &amp;env)</td></tr>
<tr class="memdesc:a918da197e28becc45718ec9b93076cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the workspace directory.  <a href="classDobbyManager.html#a918da197e28becc45718ec9b93076cf8">More...</a><br /></td></tr>
<tr class="separator:a918da197e28becc45718ec9b93076cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49230ba2390333687ef4f8270419c179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a49230ba2390333687ef4f8270419c179">cleanupContainers</a> ()</td></tr>
<tr class="memdesc:a49230ba2390333687ef4f8270419c179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of running containers and tries to kill and delete them.  <a href="classDobbyManager.html#a49230ba2390333687ef4f8270419c179">More...</a><br /></td></tr>
<tr class="separator:a49230ba2390333687ef4f8270419c179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772377ca89b442f98c325b931cb94b6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a772377ca89b442f98c325b931cb94b6d">cleanupContainer</a> (const <a class="el" href="structDobbyRunC_1_1ContainerListItem.html">DobbyRunC::ContainerListItem</a> &amp;container)</td></tr>
<tr class="memdesc:a772377ca89b442f98c325b931cb94b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up a container that is in an unknown state - used at <a class="el" href="classDobby.html" title="The root Dobby object, runs the dbus loop.">Dobby</a> startup to ensure the box is in a clean state with no leftover containers.  <a href="classDobbyManager.html#a772377ca89b442f98c325b931cb94b6d">More...</a><br /></td></tr>
<tr class="separator:a772377ca89b442f98c325b931cb94b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25898aed88e44f1677502ee50b25ca03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a25898aed88e44f1677502ee50b25ca03">cleanupContainersShutdown</a> ()</td></tr>
<tr class="memdesc:a25898aed88e44f1677502ee50b25ca03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gracefully stops and cleans up any running containers. Will emit the container stop event when a container stops.  <a href="classDobbyManager.html#a25898aed88e44f1677502ee50b25ca03">More...</a><br /></td></tr>
<tr class="separator:a25898aed88e44f1677502ee50b25ca03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f31b2285c6a8a58aa7a6220233b79f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#ac8f31b2285c6a8a58aa7a6220233b79f">handleContainerTerminate</a> (const <a class="el" href="classContainerId.html">ContainerId</a> &amp;id, const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;container, const int status)</td></tr>
<tr class="memdesc:ac8f31b2285c6a8a58aa7a6220233b79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform all the necessary cleanup and run plugins required when a container has terminated.  <a href="classDobbyManager.html#ac8f31b2285c6a8a58aa7a6220233b79f">More...</a><br /></td></tr>
<tr class="separator:ac8f31b2285c6a8a58aa7a6220233b79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25e05574f4ae49bc565bd77c9464714"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#aa25e05574f4ae49bc565bd77c9464714">onChildExit</a> ()</td></tr>
<tr class="memdesc:aa25e05574f4ae49bc565bd77c9464714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when we detect a child process has terminated.  <a href="classDobbyManager.html#aa25e05574f4ae49bc565bd77c9464714">More...</a><br /></td></tr>
<tr class="separator:aa25e05574f4ae49bc565bd77c9464714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21cf486212d6af9700206f4179079a2"><td class="memItemLeft" align="right" valign="top"><a id="aa21cf486212d6af9700206f4179079a2"></a>
std::shared_ptr&lt; <a class="el" href="classIDobbyRdkLoggingPlugin.html">IDobbyRdkLoggingPlugin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#aa21cf486212d6af9700206f4179079a2">GetContainerLogger</a> (const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;container)</td></tr>
<tr class="memdesc:aa21cf486212d6af9700206f4179079a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the instance of the logging plugin for the current container (if one is loaded) <br /></td></tr>
<tr class="separator:aa21cf486212d6af9700206f4179079a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a624aa69bcce692f4b8a66b5ea29ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a88a624aa69bcce692f4b8a66b5ea29ba">createAndStart</a> (const <a class="el" href="classContainerId.html">ContainerId</a> &amp;id, const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;container, const std::list&lt; int &gt; &amp;files)</td></tr>
<tr class="memdesc:a88a624aa69bcce692f4b8a66b5ea29ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and start a container. Set up and capture logs from all container hooks if an RDK logging plugin is loaded.  <a href="classDobbyManager.html#a88a624aa69bcce692f4b8a66b5ea29ba">More...</a><br /></td></tr>
<tr class="separator:a88a624aa69bcce692f4b8a66b5ea29ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9793aea16e8c37d663e3525925c42b28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a9793aea16e8c37d663e3525925c42b28">customiseConfig</a> (const std::shared_ptr&lt; <a class="el" href="classDobbyConfig.html">DobbyConfig</a> &gt; &amp;config, const std::string &amp;command, const std::string &amp;displaySocket, const std::vector&lt; std::string &gt; &amp;envVars)</td></tr>
<tr class="memdesc:a9793aea16e8c37d663e3525925c42b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the container config with custom options provided by the start command.  <a href="classDobbyManager.html#a9793aea16e8c37d663e3525925c42b28">More...</a><br /></td></tr>
<tr class="separator:a9793aea16e8c37d663e3525925c42b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6ee8dcae4b071816a87dc118f1d04a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a7d6ee8dcae4b071816a87dc118f1d04a">createAndStartContainer</a> (const <a class="el" href="classContainerId.html">ContainerId</a> &amp;id, const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;container, const std::list&lt; int &gt; &amp;files)</td></tr>
<tr class="memdesc:a7d6ee8dcae4b071816a87dc118f1d04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and attempts to start the container.  <a href="classDobbyManager.html#a7d6ee8dcae4b071816a87dc118f1d04a">More...</a><br /></td></tr>
<tr class="separator:a7d6ee8dcae4b071816a87dc118f1d04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188b03a5a04a14b67fdb198e692edb69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a188b03a5a04a14b67fdb198e692edb69">restartContainer</a> (const <a class="el" href="classContainerId.html">ContainerId</a> &amp;id, const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;container)</td></tr>
<tr class="memdesc:a188b03a5a04a14b67fdb198e692edb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to restart the container.  <a href="classDobbyManager.html#a188b03a5a04a14b67fdb198e692edb69">More...</a><br /></td></tr>
<tr class="separator:a188b03a5a04a14b67fdb198e692edb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf86b6860cf4299e5a7b717762e37315"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#abf86b6860cf4299e5a7b717762e37315">onPostInstallationHook</a> (const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;container)</td></tr>
<tr class="memdesc:abf86b6860cf4299e5a7b717762e37315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called at the post-installation stage of container startup.  <a href="classDobbyManager.html#abf86b6860cf4299e5a7b717762e37315">More...</a><br /></td></tr>
<tr class="separator:abf86b6860cf4299e5a7b717762e37315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb0c64d0bdee62013e83f1d7d28a419"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a9fb0c64d0bdee62013e83f1d7d28a419">onPreCreationHook</a> (const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;container)</td></tr>
<tr class="memdesc:a9fb0c64d0bdee62013e83f1d7d28a419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called at the pre-create stage of container startup.  <a href="classDobbyManager.html#a9fb0c64d0bdee62013e83f1d7d28a419">More...</a><br /></td></tr>
<tr class="separator:a9fb0c64d0bdee62013e83f1d7d28a419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83da91c4507fffc613522c38cb99d802"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a83da91c4507fffc613522c38cb99d802">onPostHaltHook</a> (const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;container)</td></tr>
<tr class="memdesc:a83da91c4507fffc613522c38cb99d802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called at the post-halt stage of container startup.  <a href="classDobbyManager.html#a83da91c4507fffc613522c38cb99d802">More...</a><br /></td></tr>
<tr class="separator:a83da91c4507fffc613522c38cb99d802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae639a4fe073f7f781b7fcc73957646c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#ae639a4fe073f7f781b7fcc73957646c6">startRuncMonitorThread</a> ()</td></tr>
<tr class="memdesc:ae639a4fe073f7f781b7fcc73957646c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a thread that monitors for SIGCHILD signals.  <a href="classDobbyManager.html#ae639a4fe073f7f781b7fcc73957646c6">More...</a><br /></td></tr>
<tr class="separator:ae639a4fe073f7f781b7fcc73957646c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7a3a490e39bcd401f920b74a3f190b"><td class="memItemLeft" align="right" valign="top"><a id="a2d7a3a490e39bcd401f920b74a3f190b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a2d7a3a490e39bcd401f920b74a3f190b">stopRuncMonitorThread</a> ()</td></tr>
<tr class="memdesc:a2d7a3a490e39bcd401f920b74a3f190b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the monitor thread and cleans up it's resources. <br /></td></tr>
<tr class="separator:a2d7a3a490e39bcd401f920b74a3f190b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5765ba67fbcc48d3bf51a0ac4485032a"><td class="memItemLeft" align="right" valign="top"><a id="a5765ba67fbcc48d3bf51a0ac4485032a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#a5765ba67fbcc48d3bf51a0ac4485032a">runcMonitorThread</a> ()</td></tr>
<tr class="memdesc:a5765ba67fbcc48d3bf51a0ac4485032a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread function that monitors for any SIGCHILD signals and if detected loops through the running containers to see if it was the runc process that spawned it (i.e. a containered init process) <br /></td></tr>
<tr class="separator:a5765ba67fbcc48d3bf51a0ac4485032a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af576f5ae627ff389028b0470cdd20052"><td class="memItemLeft" align="right" valign="top"><a id="af576f5ae627ff389028b0470cdd20052"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyManager.html#af576f5ae627ff389028b0470cdd20052">invalidContainerCleanupTask</a> ()</td></tr>
<tr class="memdesc:af576f5ae627ff389028b0470cdd20052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task that will try and cleanup invalid/unknown state containers periodically - if the container can be killed then kill it and release the id back to the pool so it can be restarted. <br /></td></tr>
<tr class="separator:af576f5ae627ff389028b0470cdd20052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad77d4cab29f2b86a68c01c0a91d3df4"><td class="memItemLeft" align="right" valign="top"><a id="aad77d4cab29f2b86a68c01c0a91d3df4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>shouldEnableSTrace</b> (const std::shared_ptr&lt; <a class="el" href="classDobbyConfig.html">DobbyConfig</a> &gt; &amp;config) const</td></tr>
<tr class="separator:aad77d4cab29f2b86a68c01c0a91d3df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a65873f16f00d42c6421ff11c82a4d242"><td class="memItemLeft" align="right" valign="top"><a id="a65873f16f00d42c6421ff11c82a4d242"></a>
ContainerStartedFunc&#160;</td><td class="memItemRight" valign="bottom"><b>mContainerStartedCb</b></td></tr>
<tr class="separator:a65873f16f00d42c6421ff11c82a4d242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ffb86e15281f1328d638579fcfaf35"><td class="memItemLeft" align="right" valign="top"><a id="ae6ffb86e15281f1328d638579fcfaf35"></a>
ContainerStoppedFunc&#160;</td><td class="memItemRight" valign="bottom"><b>mContainerStoppedCb</b></td></tr>
<tr class="separator:ae6ffb86e15281f1328d638579fcfaf35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c53442217c1609cff9dd77a70748c62"><td class="memItemLeft" align="right" valign="top"><a id="a6c53442217c1609cff9dd77a70748c62"></a>
ContainerHibernatedFunc&#160;</td><td class="memItemRight" valign="bottom"><b>mContainerHibernatedCb</b></td></tr>
<tr class="separator:a6c53442217c1609cff9dd77a70748c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d348c9a965107c147ad5aa139c701c"><td class="memItemLeft" align="right" valign="top"><a id="a73d348c9a965107c147ad5aa139c701c"></a>
ContainerHibernatedFunc&#160;</td><td class="memItemRight" valign="bottom"><b>mContainerAwokenCb</b></td></tr>
<tr class="separator:a73d348c9a965107c147ad5aa139c701c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75bcbe3f85870d0ec0d5ff6cce44b96"><td class="memItemLeft" align="right" valign="top"><a id="aa75bcbe3f85870d0ec0d5ff6cce44b96"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>mLock</b></td></tr>
<tr class="separator:aa75bcbe3f85870d0ec0d5ff6cce44b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa3b1f9e385ff28eebe6f80e8e27e99"><td class="memItemLeft" align="right" valign="top"><a id="acfa3b1f9e385ff28eebe6f80e8e27e99"></a>
std::map&lt; <a class="el" href="classContainerId.html">ContainerId</a>, std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mContainers</b></td></tr>
<tr class="separator:acfa3b1f9e385ff28eebe6f80e8e27e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e886b8747d3aeb61aad9d2d71662db"><td class="memItemLeft" align="right" valign="top"><a id="a34e886b8747d3aeb61aad9d2d71662db"></a>
std::multimap&lt; <a class="el" href="classContainerId.html">ContainerId</a>, pid_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mContainerExecPids</b></td></tr>
<tr class="separator:a34e886b8747d3aeb61aad9d2d71662db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3ba100fa161e0cf9a69b7d7128ec93"><td class="memItemLeft" align="right" valign="top"><a id="adc3ba100fa161e0cf9a69b7d7128ec93"></a>
const std::shared_ptr&lt; <a class="el" href="classIDobbyEnv.html">IDobbyEnv</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mEnvironment</b></td></tr>
<tr class="separator:adc3ba100fa161e0cf9a69b7d7128ec93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ac31ac87ea9cc08591c8037f02305e"><td class="memItemLeft" align="right" valign="top"><a id="a77ac31ac87ea9cc08591c8037f02305e"></a>
const std::shared_ptr&lt; <a class="el" href="classIDobbyUtils__v3.html">IDobbyUtils</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mUtilities</b></td></tr>
<tr class="separator:a77ac31ac87ea9cc08591c8037f02305e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaf42d1b47b2e7efd02da1223eb8f64"><td class="memItemLeft" align="right" valign="top"><a id="a0eaf42d1b47b2e7efd02da1223eb8f64"></a>
const std::shared_ptr&lt; <a class="el" href="classIDobbyIPCUtils.html">IDobbyIPCUtils</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mIPCUtilities</b></td></tr>
<tr class="separator:a0eaf42d1b47b2e7efd02da1223eb8f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afd423c7358f7450a212190f3fef966"><td class="memItemLeft" align="right" valign="top"><a id="a1afd423c7358f7450a212190f3fef966"></a>
const std::shared_ptr&lt; const <a class="el" href="classIDobbySettings.html">IDobbySettings</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mSettings</b></td></tr>
<tr class="separator:a1afd423c7358f7450a212190f3fef966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fde94b51c263ed47b8fbbdeb9f1b36"><td class="memItemLeft" align="right" valign="top"><a id="a18fde94b51c263ed47b8fbbdeb9f1b36"></a>
std::unique_ptr&lt; <a class="el" href="classDobbyLogger.html">DobbyLogger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mLogger</b></td></tr>
<tr class="separator:a18fde94b51c263ed47b8fbbdeb9f1b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea576b2e5826b9eab0d45b68093a741"><td class="memItemLeft" align="right" valign="top"><a id="a8ea576b2e5826b9eab0d45b68093a741"></a>
std::unique_ptr&lt; <a class="el" href="classDobbyRunC.html">DobbyRunC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mRunc</b></td></tr>
<tr class="separator:a8ea576b2e5826b9eab0d45b68093a741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae172a1213a72d74052435256d636f91b"><td class="memItemLeft" align="right" valign="top"><a id="ae172a1213a72d74052435256d636f91b"></a>
sem_t&#160;</td><td class="memItemRight" valign="bottom"><b>mRuncMonitorThreadStartedSem</b></td></tr>
<tr class="separator:ae172a1213a72d74052435256d636f91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42f9b95845837eb6ca473e912c7a8ae"><td class="memItemLeft" align="right" valign="top"><a id="af42f9b95845837eb6ca473e912c7a8ae"></a>
std::thread&#160;</td><td class="memItemRight" valign="bottom"><b>mRuncMonitorThread</b></td></tr>
<tr class="separator:af42f9b95845837eb6ca473e912c7a8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9388fe2a9b8b1e53cac0bb78e9c856"><td class="memItemLeft" align="right" valign="top"><a id="a9a9388fe2a9b8b1e53cac0bb78e9c856"></a>
std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mRuncMonitorTerminate</b></td></tr>
<tr class="separator:a9a9388fe2a9b8b1e53cac0bb78e9c856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78b4cee675a5ad4086eab6c07a35902"><td class="memItemLeft" align="right" valign="top"><a id="af78b4cee675a5ad4086eab6c07a35902"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mCleanupTaskTimerId</b></td></tr>
<tr class="separator:af78b4cee675a5ad4086eab6c07a35902"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main object which starts / stops / manages the containers. </p>
<p>This is where most of the work is done for creating and monitoring containers.</p>
<p><a href="https://groups.google.com/a/opencontainers.org/forum/m/#!topic/dev/Y7p6YW8zr4s">https://groups.google.com/a/opencontainers.org/forum/m/#!topic/dev/Y7p6YW8zr4s</a> </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a51074edde8c775e771f9420d948752ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51074edde8c775e771f9420d948752ea">&#9670;&nbsp;</a></span>addMount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::addMount </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>mountFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mountData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a mount to a running container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cd</td><td>The descriptor of the container to checkpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>The source path of the mount </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>The destination path of the mount </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mountFlags</td><td>The mount flags is vector of strings containing the mount flags e.g. "rbind, ro" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mountData</td><td>a string containing the mountdata</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a container was successfully restored. </dd></dl>

</div>
</div>
<a id="a772377ca89b442f98c325b931cb94b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772377ca89b442f98c325b931cb94b6d">&#9670;&nbsp;</a></span>cleanupContainer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::cleanupContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDobbyRunC_1_1ContainerListItem.html">DobbyRunC::ContainerListItem</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cleans up a container that is in an unknown state - used at <a class="el" href="classDobby.html" title="The root Dobby object, runs the dbus loop.">Dobby</a> startup to ensure the box is in a clean state with no leftover containers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Container info returned by crun list command </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49230ba2390333687ef4f8270419c179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49230ba2390333687ef4f8270419c179">&#9670;&nbsp;</a></span>cleanupContainers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyManager::cleanupContainers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a list of running containers and tries to kill and delete them. </p>
<p>Will run the postHalt hook for the container where possible (some hooks might fail as the container bundle cannot be guaranteed to exist at this time)</p>
<p>Designed as a crash-recovery mechanism as we should clean up all our containers if the daemon shut down gracefully </p>

</div>
</div>
<a id="a25898aed88e44f1677502ee50b25ca03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25898aed88e44f1677502ee50b25ca03">&#9670;&nbsp;</a></span>cleanupContainersShutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyManager::cleanupContainersShutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gracefully stops and cleans up any running containers. Will emit the container stop event when a container stops. </p>
<p>Designed to be called when the daemon is going down (e.g. SIGTERM) </p>

</div>
</div>
<a id="a88a624aa69bcce692f4b8a66b5ea29ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a624aa69bcce692f4b8a66b5ea29ba">&#9670;&nbsp;</a></span>createAndStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::createAndStart </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classContainerId.html">ContainerId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>files</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and start a container. Set up and capture logs from all container hooks if an RDK logging plugin is loaded. </p>
<p>If container-&gt;customConfigFilePath is set, the container will use that config.json file instead of the onein the bundle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>id of the container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>The object that wraps up the container details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">files</td><td>List of fds to preserve inside the container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d6ee8dcae4b071816a87dc118f1d04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6ee8dcae4b071816a87dc118f1d04a">&#9670;&nbsp;</a></span>createAndStartContainer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::createAndStartContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classContainerId.html">ContainerId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>files</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and attempts to start the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id string for the container. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>The object that wraps up the container details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startState</td><td>The start state object of the files. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>The custom command to run instead of the args in the config file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a9793aea16e8c37d663e3525925c42b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9793aea16e8c37d663e3525925c42b28">&#9670;&nbsp;</a></span>customiseConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::customiseConfig </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classDobbyConfig.html">DobbyConfig</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>displaySocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>envVars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the container config with custom options provided by the start command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>The custom command to run instead of the args in the config file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displaySocket</td><td>Path to a westeros socket to mount into the container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">envVars</td><td>Custom env vars to add to the container</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if modifications were made, false if no changes made </dd></dl>

</div>
</div>
<a id="a26f396a3d1f2f145aa05ff23bfc50685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f396a3d1f2f145aa05ff23bfc50685">&#9670;&nbsp;</a></span>execInContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::execInContainer </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a command in a running container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cd</td><td>The descriptor of the container to execute the command in. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>Command to be executed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Options to execute the command with.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a container with a matching descriptor was found and the command was run </dd></dl>

</div>
</div>
<a id="ac8f31b2285c6a8a58aa7a6220233b79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f31b2285c6a8a58aa7a6220233b79f">&#9670;&nbsp;</a></span>handleContainerTerminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyManager::handleContainerTerminate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classContainerId.html">ContainerId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform all the necessary cleanup and run plugins required when a container has terminated. </p>
<p>Will also delete the container so the ID can be re-used</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>ID of the container that has terminated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Information about the container that has terminated (rootfs, config etc) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Exit status of the container runtime </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac201b6ea9cc3aaae0c23b0dd13fc2ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac201b6ea9cc3aaae0c23b0dd13fc2ecc">&#9670;&nbsp;</a></span>hibernateContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::hibernateContainer </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps a running container's processes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cd</td><td>The descriptor of the container to checkpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>Additional options</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a container with a matching descriptor was found and its processes were dumped. </dd></dl>

</div>
</div>
<a id="a916432f3341a3eeae5de5e06807374e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916432f3341a3eeae5de5e06807374e3">&#9670;&nbsp;</a></span>listContainers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; std::pair&lt; int32_t, <a class="el" href="classContainerId.html">ContainerId</a> &gt; &gt; DobbyManager::listContainers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all the containers. </p>
<p>The returned list contains the id of all the containers we know about in their various states. Just because a container id is in the list it doesn't necessarily mean it's actually running, it could be in either the starting or stopping phase.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classDobbyManager.html#abceecde3a6a164e13f3799a5dd4a3636" title="Returns the state of a given container.">DobbyManager::stateOfContainer</a> for a way to retrieve the status of the container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a list of all the containers. </dd></dl>

</div>
</div>
<a id="a7ab07082f515abc77f157954747cad11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab07082f515abc77f157954747cad11">&#9670;&nbsp;</a></span>ociConfigOfContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DobbyManager::ociConfigOfContainer </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging method to allow you to retrieve the OCI config.json spec used to create the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cd</td><td>The descriptor of the container to get the config.json of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the config.json string. </dd></dl>

</div>
</div>
<a id="aa25e05574f4ae49bc565bd77c9464714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25e05574f4ae49bc565bd77c9464714">&#9670;&nbsp;</a></span>onChildExit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyManager::onChildExit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when we detect a child process has terminated. </p>
<p>The child process will typically be a runc instance for a container. To check we need to iterate over the pids we know about and check if they have terminated.</p>
<p>This is how we determine when a container dies, we look for the child process death signal. </p>

</div>
</div>
<a id="a83da91c4507fffc613522c38cb99d802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83da91c4507fffc613522c38cb99d802">&#9670;&nbsp;</a></span>onPostHaltHook()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::onPostHaltHook </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called at the post-halt stage of container startup. </p>
<p>Uses the map of rdkPlugin names/data in the container config to determine which plugins to execute. RDK plugins are loaded from disk in the ctor of <a class="el" href="classDobbyContainer.html" title="Wrapper object used to store container resources.">DobbyContainer</a> if any rdk plugins are required</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Container wrapper object for the container to execute the plugins on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all required postInstallation hooks were successful </dd></dl>

</div>
</div>
<a id="abf86b6860cf4299e5a7b717762e37315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf86b6860cf4299e5a7b717762e37315">&#9670;&nbsp;</a></span>onPostInstallationHook()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::onPostInstallationHook </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called at the post-installation stage of container startup. </p>
<p>Uses the map of rdkPlugin names/data in the container config to determine which plugins to execute. RDK plugins are loaded from disk in the constructor of <a class="el" href="classDobbyContainer.html" title="Wrapper object used to store container resources.">DobbyContainer</a> if any rdk plugins are required</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Container wrapper object for the container to execute the plugins on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all required postInstallation hooks were successful </dd></dl>

</div>
</div>
<a id="a9fb0c64d0bdee62013e83f1d7d28a419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb0c64d0bdee62013e83f1d7d28a419">&#9670;&nbsp;</a></span>onPreCreationHook()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::onPreCreationHook </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called at the pre-create stage of container startup. </p>
<p>Uses the map of rdkPlugin names/data in the container config to determine which plugins to execute. RDK plugins are loaded from disk in the constructor of <a class="el" href="classDobbyContainer.html" title="Wrapper object used to store container resources.">DobbyContainer</a> if any rdk plugins are required</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>Container wrapper object for the container to execute the plugins on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all required preCreate hooks were successful </dd></dl>

</div>
</div>
<a id="ae68bb880628681639726ce3e0d48067d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68bb880628681639726ce3e0d48067d">&#9670;&nbsp;</a></span>pauseContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::pauseContainer </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Freezes a running container. </p>
<p>Currently we have no use case for pause/resume containers so the method hasn't been implemented, however when testing manually I've discovered it actually works quite well.</p>
<p>If wanting to have a play you can run the following on the command line </p><pre class="fragment">runc --root /var/run/runc pause &lt;id&gt;
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cd</td><td>The descriptor of the container to pause.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a container with a matching descriptor was found and it was frozen. </dd></dl>

</div>
</div>
<a id="a7a3582f066e8fea7425e4bbd26da194c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3582f066e8fea7425e4bbd26da194c">&#9670;&nbsp;</a></span>removeMount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::removeMount </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes a mount from a running container </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cd</td><td>The descriptor of the container to checkpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a container was successfully restored. </dd></dl>

</div>
</div>
<a id="a188b03a5a04a14b67fdb198e692edb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188b03a5a04a14b67fdb198e692edb69">&#9670;&nbsp;</a></span>restartContainer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::restartContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classContainerId.html">ContainerId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unique_ptr&lt; <a class="el" href="classDobbyContainer.html">DobbyContainer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to restart the container. </p>
<p>Called internally when we've detected a container shutdown and the config has indicated we should try and auto-restart the container.</p>
<p>From the runc tool's POV this is start of a new container.</p>
<p>Note when restarting, we don't regenerate the rootfs or config.json files for the bundle and the postConstruction hook is not called. However the preStart, postStart and postStop hooks will be called.</p>
<p>Any file descriptors that were passed into the container when it was first launched will be passed in again. The <a class="el" href="classDobbyContainer.html" title="Wrapper object used to store container resources.">DobbyContainer</a> object will have stored them when the container was created the first time.</p>
<dl class="section warning"><dt>Warning</dt><dd>this function is called from the thread that monitors the child pids, not the main thread, however it is called with mLock held.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id of the container to re-start. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">container</td><td>The container object storing the container details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if runc executed the request, however this doesn't necessarily mean the container is up and running successfully. </dd></dl>

</div>
</div>
<a id="a2d4e604d228f20045b2a4624d0295a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4e604d228f20045b2a4624d0295a30">&#9670;&nbsp;</a></span>resumeContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::resumeContainer </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thaws a frozen container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cd</td><td>The descriptor of the container to resume.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a container with a matching descriptor was found and it was resumed. </dd></dl>

</div>
</div>
<a id="a856645daacea432a97c72d88411f33cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856645daacea432a97c72d88411f33cd">&#9670;&nbsp;</a></span>setupSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyManager::setupSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures the linux system for enabling features needed for runc. </p>
<p>This method is equivalent to performing the following on the cmdline </p><pre class="fragment">ulimit -c unlimited

echo "1" &gt; /proc/sys/net/ipv4/ip_forward
</pre><p>See the comments in the code for why each step is needed </p>

</div>
</div>
<a id="a918da197e28becc45718ec9b93076cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918da197e28becc45718ec9b93076cf8">&#9670;&nbsp;</a></span>setupWorkspace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyManager::setupWorkspace </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classIDobbyEnv.html">IDobbyEnv</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>env</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configures the workspace directory. </p>
<p>The supplied path will be created if it doesn't exist. It should be on writable mount point with an adequate amount of space available.</p>
<p>The workspace is where bundle directories are created for each container and also where various temporary files are created. However the runc tool doesn't use it and log files are written to /var/log/...</p>
<p>TODO: show tree of workspace layout</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The absolute path to the workspace </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66e3c66c1edf14b1f292fb28004968d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e3c66c1edf14b1f292fb28004968d3">&#9670;&nbsp;</a></span>startContainerFromBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DobbyManager::startContainerFromBundle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classContainerId.html">ContainerId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bundlePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::list&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>displaySocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>envVars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Where the magic begins ... attempts to create a container from an OCI bundle*. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The id string for the container </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bundlePath</td><td>The absolute path to the OCI bundle* </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">files</td><td>A list of file descriptors to pass into the container, can be empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">command</td><td>The custom command to run instead of the args in the config file (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a container descriptor, which is just a unique number that identifies the container. </dd></dl>

</div>
</div>
<a id="ae639a4fe073f7f781b7fcc73957646c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae639a4fe073f7f781b7fcc73957646c6">&#9670;&nbsp;</a></span>startRuncMonitorThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyManager::startRuncMonitorThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts a thread that monitors for SIGCHILD signals. </p>
<p>This thread is used to determine when one of our spawned child runc processes has died.</p>
<p>Failure to create the thread should be considered fatal.</p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="abceecde3a6a164e13f3799a5dd4a3636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abceecde3a6a164e13f3799a5dd4a3636">&#9670;&nbsp;</a></span>stateOfContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t DobbyManager::stateOfContainer </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the state of a given container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cd</td><td>The descriptor of the container to get the state of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>one of the possible state values. </dd></dl>

</div>
</div>
<a id="a50849443ccba22c698d223234125471b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50849443ccba22c698d223234125471b">&#9670;&nbsp;</a></span>statsOfContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string DobbyManager::statsOfContainer </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the stats for the container. </p>
<p>This is primarily a debugging method, used to get statistics on the container and roughly correlates to the 'runc events &ndash;stats &lt;id&gt;' call.</p>
<p>The reply is a json formatted string containing some info, it's form may change over time. </p><pre class="fragment">{
    "id": "blah",
    "state": "running",
    "timestamp": 348134887768,
    "pids": [ 1234, 1245 ],
    "cpu": {
        "usage": {
            "total":734236982,
            "percpu":[348134887,386102095]
        }
    },
    "memory":{
        "user": {
            "limit":41943040,
            "usage":356352,
            "max":524288,
            "failcnt":0
        }
    }
    "gpu":{
        "memory": {
            "limit":41943040,
            "usage":356352,
            "max":524288,
            "failcnt":0
        }
    }
    ...
}
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cd</td><td>The container descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Json formatted string with the info for the container, on failure an empty string. </dd></dl>

</div>
</div>
<a id="abc24032118b91fc1660ae4be7dedaf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc24032118b91fc1660ae4be7dedaf2f">&#9670;&nbsp;</a></span>stopContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::stopContainer </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>withPrejudice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops a running container. </p>
<p>If withPrejudice is not specified (the default) then we send the init process within the container a SIGTERM.</p>
<p>If the withPrejudice is true then we use the SIGKILL signal.</p>
<p>This call is asynchronous, i.e. it is a request to stop rather than a blocking call that ensures the container is stopped before returning.</p>
<p>The <em>mContainerStoppedCb</em> callback will be called when the container has actually been torn down.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cd</td><td>The descriptor of the container to stop. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">withPrejudice</td><td>If true the container process is killed with SIGKILL, otherwise SIGTERM is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a container with a matching id was found and a signal sent successfully to it. </dd></dl>

</div>
</div>
<a id="a61c23b8b21675ad8f377b62823a2fd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c23b8b21675ad8f377b62823a2fd46">&#9670;&nbsp;</a></span>wakeupContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyManager::wakeupContainer </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>cd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wakeup a checkpointed container from existing dump. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cd</td><td>The descriptor of the container to checkpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a container was successfully restored. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>daemon/lib/source/include/<a class="el" href="DobbyManager_8h_source.html">DobbyManager.h</a></li>
<li>daemon/lib/source/DobbyManager.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
