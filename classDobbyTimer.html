<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dobby: DobbyTimer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Dobby<span id="projectnumber">&#160;3.0</span>
   </div>
   <div id="projectbrief">Dobby “Docker based Thingy” is a tool for managing and running OCI containers using crun</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDobbyTimer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DobbyTimer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Utility object that can be used to register a callback function to execute in the future.  
 <a href="classDobbyTimer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DobbyTimer_8h_source.html">DobbyTimer.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for DobbyTimer:</div>
<div class="dyncontent">
<div class="center"><img src="classDobbyTimer__coll__graph.png" border="0" usemap="#aDobbyTimer_coll__map" alt="Collaboration graph"/></div>
<map name="aDobbyTimer_coll__map" id="aDobbyTimer_coll__map">
<area shape="rect" title="Utility object that can be used to register a callback function to execute in the future." alt="" coords="63,93,166,119"/>
<area shape="rect" href="classAICommon_1_1IDGenerator.html" title=" " alt="" coords="5,5,224,31"/>
<area shape="poly" title=" " alt="" coords="117,45,117,93,112,93,112,45"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDobbyTimer_1_1tagTimerEntry.html">tagTimerEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyTimer_1_1TimerEntryCompare.html">TimerEntryCompare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3a5567296c1adeeafd31a2b44c4e1ff7" id="r_a3a5567296c1adeeafd31a2b44c4e1ff7"><td class="memItemLeft" align="right" valign="top"><a id="a3a5567296c1adeeafd31a2b44c4e1ff7" name="a3a5567296c1adeeafd31a2b44c4e1ff7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>stop</b> ()</td></tr>
<tr class="memdesc:a3a5567296c1adeeafd31a2b44c4e1ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the poll loop thread and cancels all timers. <br /></td></tr>
<tr class="separator:a3a5567296c1adeeafd31a2b44c4e1ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3b17930cd005d1c77637a06c89c878" id="r_abc3b17930cd005d1c77637a06c89c878"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyTimer.html#abc3b17930cd005d1c77637a06c89c878">add</a> (const std::chrono::milliseconds &amp;timeout, bool oneShot, const std::function&lt; bool()&gt; &amp;func)</td></tr>
<tr class="memdesc:abc3b17930cd005d1c77637a06c89c878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new timer to the timer queue.  <br /></td></tr>
<tr class="separator:abc3b17930cd005d1c77637a06c89c878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2937926dd0798374ce6205629afe24" id="r_aff2937926dd0798374ce6205629afe24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyTimer.html#aff2937926dd0798374ce6205629afe24">remove</a> (int timerId)</td></tr>
<tr class="memdesc:aff2937926dd0798374ce6205629afe24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given timer from the timer queue.  <br /></td></tr>
<tr class="separator:aff2937926dd0798374ce6205629afe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a57dc72be0801778cee1924a48820216c" id="r_a57dc72be0801778cee1924a48820216c"><td class="memItemLeft" align="right" valign="top"><a id="a57dc72be0801778cee1924a48820216c" name="a57dc72be0801778cee1924a48820216c"></a>
typedef struct <a class="el" href="structDobbyTimer_1_1tagTimerEntry.html">DobbyTimer::tagTimerEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><b>TimerEntry</b></td></tr>
<tr class="separator:a57dc72be0801778cee1924a48820216c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad3ef6c3c89577747b6c239093513222a" id="r_ad3ef6c3c89577747b6c239093513222a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyTimer.html#ad3ef6c3c89577747b6c239093513222a">timerThread</a> ()</td></tr>
<tr class="memdesc:ad3ef6c3c89577747b6c239093513222a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread function that runs the timer poll loop.  <br /></td></tr>
<tr class="separator:ad3ef6c3c89577747b6c239093513222a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e55f35499dc69b766840142ba7cb063" id="r_a7e55f35499dc69b766840142ba7cb063"><td class="memItemLeft" align="right" valign="top"><a id="a7e55f35499dc69b766840142ba7cb063" name="a7e55f35499dc69b766840142ba7cb063"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateTimerFd</b> () const</td></tr>
<tr class="memdesc:a7e55f35499dc69b766840142ba7cb063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the item on the head of the expiry queue into the timerfd for the next wake-up time. <br /></td></tr>
<tr class="separator:a7e55f35499dc69b766840142ba7cb063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79aa4213a84cd42a3d5c3599344995d6" id="r_a79aa4213a84cd42a3d5c3599344995d6"><td class="memItemLeft" align="right" valign="top">struct timespec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyTimer.html#a79aa4213a84cd42a3d5c3599344995d6">calcAbsTime</a> (const struct timespec &amp;now, const std::chrono::milliseconds &amp;timeout) const</td></tr>
<tr class="memdesc:a79aa4213a84cd42a3d5c3599344995d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the a new time value based on the time now and the supplied millisecond offset.  <br /></td></tr>
<tr class="separator:a79aa4213a84cd42a3d5c3599344995d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aecd95ebca9d2b38d40544e98d5b8acc2" id="r_aecd95ebca9d2b38d40544e98d5b8acc2"><td class="memItemLeft" align="right" valign="top"><a id="aecd95ebca9d2b38d40544e98d5b8acc2" name="aecd95ebca9d2b38d40544e98d5b8acc2"></a>
std::multiset&lt; <a class="el" href="structDobbyTimer_1_1tagTimerEntry.html">TimerEntry</a>, <a class="el" href="classDobbyTimer_1_1TimerEntryCompare.html">TimerEntryCompare</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mTimersQueue</b></td></tr>
<tr class="separator:aecd95ebca9d2b38d40544e98d5b8acc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99223258f839c86bfb3fe2f1cccbb419" id="r_a99223258f839c86bfb3fe2f1cccbb419"><td class="memItemLeft" align="right" valign="top"><a id="a99223258f839c86bfb3fe2f1cccbb419" name="a99223258f839c86bfb3fe2f1cccbb419"></a>
std::recursive_mutex&#160;</td><td class="memItemRight" valign="bottom"><b>mLock</b></td></tr>
<tr class="separator:a99223258f839c86bfb3fe2f1cccbb419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca09268d153c8c2ca15aeb81047ef50" id="r_a4ca09268d153c8c2ca15aeb81047ef50"><td class="memItemLeft" align="right" valign="top"><a id="a4ca09268d153c8c2ca15aeb81047ef50" name="a4ca09268d153c8c2ca15aeb81047ef50"></a>
std::thread&#160;</td><td class="memItemRight" valign="bottom"><b>mThread</b></td></tr>
<tr class="separator:a4ca09268d153c8c2ca15aeb81047ef50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2962d3d82b9452d2edd23c9b0030f588" id="r_a2962d3d82b9452d2edd23c9b0030f588"><td class="memItemLeft" align="right" valign="top"><a id="a2962d3d82b9452d2edd23c9b0030f588" name="a2962d3d82b9452d2edd23c9b0030f588"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mTimerFd</b></td></tr>
<tr class="separator:a2962d3d82b9452d2edd23c9b0030f588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc10d905b5bd8754340380068e7cd8c" id="r_a4fc10d905b5bd8754340380068e7cd8c"><td class="memItemLeft" align="right" valign="top"><a id="a4fc10d905b5bd8754340380068e7cd8c" name="a4fc10d905b5bd8754340380068e7cd8c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mEventFd</b></td></tr>
<tr class="separator:a4fc10d905b5bd8754340380068e7cd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a260c5524fa5abb91189e1ee8e2254b" id="r_a0a260c5524fa5abb91189e1ee8e2254b"><td class="memItemLeft" align="right" valign="top"><a id="a0a260c5524fa5abb91189e1ee8e2254b" name="a0a260c5524fa5abb91189e1ee8e2254b"></a>
<a class="el" href="classAICommon_1_1IDGenerator.html">AICommon::IDGenerator</a>&lt; 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mIdGenerator</b></td></tr>
<tr class="separator:a0a260c5524fa5abb91189e1ee8e2254b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Utility object that can be used to register a callback function to execute in the future. </p>
<p>Multiple callbacks can be registered via this object, internally it runs a thread with a single timerfd that wakes up at the correct time and then calls any handlers registered.</p>
<p>All callbacks are processed in the same thread, so obviously one timer handler can block all the others, clients should bear this in mind.</p>
<dl class="section warning"><dt>Warning</dt><dd>Currently if you try and call <a class="el" href="classDobbyTimer.html#aff2937926dd0798374ce6205629afe24" title="Removes the given timer from the timer queue.">DobbyTimer::remove</a> from inside the handler callback function it will return with an error. If you want to stop a repeating timer then return false from the handler.</dd>
<dd>
This object currently only supports a maximum of 63 timers. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abc3b17930cd005d1c77637a06c89c878" name="abc3b17930cd005d1c77637a06c89c878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3b17930cd005d1c77637a06c89c878">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DobbyTimer::add </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>oneShot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool()&gt; &amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new timer to the timer queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The time after which to call the supplied handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oneShot</td><td>If true the timer is automatically removed after it times out the first time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>The handler function to call when the timer times out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success returns a (greater than zero) timer id integer which identifies the timer, on failure -1 is returned. </dd></dl>

</div>
</div>
<a id="a79aa4213a84cd42a3d5c3599344995d6" name="a79aa4213a84cd42a3d5c3599344995d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79aa4213a84cd42a3d5c3599344995d6">&#9670;&#160;</a></span>calcAbsTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct timespec DobbyTimer::calcAbsTime </td>
          <td>(</td>
          <td class="paramtype">const struct timespec &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the a new time value based on the time now and the supplied millisecond offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The base time to calculate the new offset from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The milliseconds offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a timespec that is the base value plus the offset. </dd></dl>

</div>
</div>
<a id="aff2937926dd0798374ce6205629afe24" name="aff2937926dd0798374ce6205629afe24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2937926dd0798374ce6205629afe24">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyTimer::remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the given timer from the timer queue. </p>
<p>Once this method returns (successfully) you are guaranteed that the timer handler will not be called, i.e. this is synchronisation point.</p>
<p>This method will fail if called from the context of a timer handler, if you want to cancel a repeating timer then just return false in the handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timerId</td><td>The id of the timer to remove as returned by the <a class="el" href="classDobbyTimer.html#abc3b17930cd005d1c77637a06c89c878" title="Adds a new timer to the timer queue.">add()</a> method</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the timer was found and was removed from the queue, otherwise false </dd></dl>

</div>
</div>
<a id="ad3ef6c3c89577747b6c239093513222a" name="ad3ef6c3c89577747b6c239093513222a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ef6c3c89577747b6c239093513222a">&#9670;&#160;</a></span>timerThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyTimer::timerThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The thread function that runs the timer poll loop. </p>
<p>This simply polls on an timerfd and eventfd. The timerfd is obviously for waking up and calling any installed timers at the right time. The eventfd is used to kill the poll loop at shutdown time. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>utils/source/<a class="el" href="DobbyTimer_8h_source.html">DobbyTimer.h</a></li>
<li>utils/source/<b>DobbyTimer.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
