<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dobby: StorageHelper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Dobby<span id="projectnumber">&#160;3.0</span>
   </div>
   <div id="projectbrief">Dobby “Docker based Thingy” is a tool for managing and running OCI containers using crun</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classStorageHelper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">StorageHelper Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Help functions for <a class="el" href="classStorage.html" title="Dobby RDK Storage Plugin.">Storage</a> related things.  
 <a href="classStorageHelper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StorageHelper_8h_source.html">StorageHelper.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afc816104c52b9e80211fe4b6eaf3a53a" id="r_afc816104c52b9e80211fe4b6eaf3a53a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHelper.html#afc816104c52b9e80211fe4b6eaf3a53a">loopDeviceAssociate</a> (int fileFd, std::string *loopDevPath)</td></tr>
<tr class="memdesc:afc816104c52b9e80211fe4b6eaf3a53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates a give file descriptor with a loop device.  <br /></td></tr>
<tr class="separator:afc816104c52b9e80211fe4b6eaf3a53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f81a359083913d7f2aeb8113c35837" id="r_a83f81a359083913d7f2aeb8113c35837"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHelper.html#a83f81a359083913d7f2aeb8113c35837">openLoopDevice</a> (std::string *loopDevice)</td></tr>
<tr class="memdesc:a83f81a359083913d7f2aeb8113c35837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to open an available loop device.  <br /></td></tr>
<tr class="separator:a83f81a359083913d7f2aeb8113c35837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183101593a6f2f3c152deea2a4c77224" id="r_a183101593a6f2f3c152deea2a4c77224"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHelper.html#a183101593a6f2f3c152deea2a4c77224">attachFileToLoopDevice</a> (int loopFd, int fileFd)</td></tr>
<tr class="memdesc:a183101593a6f2f3c152deea2a4c77224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to attach the file to the loop device.  <br /></td></tr>
<tr class="separator:a183101593a6f2f3c152deea2a4c77224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20be18e76cd2904d36966dae93ff83e7" id="r_a20be18e76cd2904d36966dae93ff83e7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHelper.html#a20be18e76cd2904d36966dae93ff83e7">attachLoopDevice</a> (const std::string &amp;sourceFile, std::string *loopDevice)</td></tr>
<tr class="memdesc:a20be18e76cd2904d36966dae93ff83e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches the given file to an available loop device.  <br /></td></tr>
<tr class="separator:a20be18e76cd2904d36966dae93ff83e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d85f5f7e2cd5faa35c1433c5b22f954" id="r_a7d85f5f7e2cd5faa35c1433c5b22f954"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHelper.html#a7d85f5f7e2cd5faa35c1433c5b22f954">createFileIfNeeded</a> (const std::string &amp;filePath, const size_t storageSize, const uid_t userId, const std::string &amp;fileSystem)</td></tr>
<tr class="memdesc:a7d85f5f7e2cd5faa35c1433c5b22f954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if file exists, if yes return true, if not try to create it. If success return true, if file don't exist and cannot be created return false.  <br /></td></tr>
<tr class="separator:a7d85f5f7e2cd5faa35c1433c5b22f954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795a1d4143c767fd617e54d52a1e19c9" id="r_a795a1d4143c767fd617e54d52a1e19c9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHelper.html#a795a1d4143c767fd617e54d52a1e19c9">cleanMountLostAndFound</a> (const std::string &amp;mountPoint, const std::string &amp;logTag)</td></tr>
<tr class="memdesc:a795a1d4143c767fd617e54d52a1e19c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logs and deletes any files found in the lost+found directory of the mount point.  <br /></td></tr>
<tr class="separator:a795a1d4143c767fd617e54d52a1e19c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72452cf3115ac710ccaa79c1054d994" id="r_ac72452cf3115ac710ccaa79c1054d994"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHelper.html#ac72452cf3115ac710ccaa79c1054d994">getLoopDevice</a> (const std::string &amp;backingFile)</td></tr>
<tr class="memdesc:ac72452cf3115ac710ccaa79c1054d994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the loop device for a given backing file.  <br /></td></tr>
<tr class="separator:ac72452cf3115ac710ccaa79c1054d994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fe0b1516ed493068ddc0fbc85312ef" id="r_a38fe0b1516ed493068ddc0fbc85312ef"><td class="memItemLeft" align="right" valign="top"><a id="a38fe0b1516ed493068ddc0fbc85312ef" name="a38fe0b1516ed493068ddc0fbc85312ef"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>getMountOptions</b> (const std::list&lt; std::string &gt; &amp;mountOptions)</td></tr>
<tr class="separator:a38fe0b1516ed493068ddc0fbc85312ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08602b5aa0f9567bd591ec3b486f3d12" id="r_a08602b5aa0f9567bd591ec3b486f3d12"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHelper.html#a08602b5aa0f9567bd591ec3b486f3d12">rmdirRecursive</a> (int dirFd, const std::string &amp;path)</td></tr>
<tr class="memdesc:a08602b5aa0f9567bd591ec3b486f3d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a directory and all it's contents.  <br /></td></tr>
<tr class="separator:a08602b5aa0f9567bd591ec3b486f3d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f0b71f475c655a31bbbf0e6771d150" id="r_a77f0b71f475c655a31bbbf0e6771d150"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHelper.html#a77f0b71f475c655a31bbbf0e6771d150">rmdirContents</a> (int dirFd, const std::string &amp;path)</td></tr>
<tr class="memdesc:a77f0b71f475c655a31bbbf0e6771d150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the contents of a directory but leave the actual directory in place.  <br /></td></tr>
<tr class="separator:a77f0b71f475c655a31bbbf0e6771d150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa358b8c96d45ea245c4fd2fcd6b9ccbf" id="r_aa358b8c96d45ea245c4fd2fcd6b9ccbf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHelper.html#aa358b8c96d45ea245c4fd2fcd6b9ccbf">deleteRecursive</a> (int dirfd, int depth)</td></tr>
<tr class="memdesc:aa358b8c96d45ea245c4fd2fcd6b9ccbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive function that deletes everything within the supplied directory (as a descriptor).  <br /></td></tr>
<tr class="separator:aa358b8c96d45ea245c4fd2fcd6b9ccbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Help functions for <a class="el" href="classStorage.html" title="Dobby RDK Storage Plugin.">Storage</a> related things. </p>
<p>All low level help functions that doesn't rely on current state </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a183101593a6f2f3c152deea2a4c77224" name="a183101593a6f2f3c152deea2a4c77224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183101593a6f2f3c152deea2a4c77224">&#9670;&#160;</a></span>attachFileToLoopDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageHelper::attachFileToLoopDevice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>loopFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fileFd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to attach the file to the loop device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loopFd</td><td>An open file descriptor to the loop device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileFd</td><td>An open file descriptor that should be associate with the loop device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success a positive file desccriptor corresponding to a free loop device, -1 on error. </dd></dl>

</div>
</div>
<a id="a20be18e76cd2904d36966dae93ff83e7" name="a20be18e76cd2904d36966dae93ff83e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20be18e76cd2904d36966dae93ff83e7">&#9670;&#160;</a></span>attachLoopDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StorageHelper::attachLoopDevice </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sourceFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>loopDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches the given file to an available loop device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sourceFile</td><td>The path to the image file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">loopDevice</td><td>The path to the loop device that was attached.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the file descriptor to the loop device if attached, otherwise -1. </dd></dl>

</div>
</div>
<a id="a795a1d4143c767fd617e54d52a1e19c9" name="a795a1d4143c767fd617e54d52a1e19c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795a1d4143c767fd617e54d52a1e19c9">&#9670;&#160;</a></span>cleanMountLostAndFound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageHelper::cleanMountLostAndFound </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mountPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>logTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Logs and deletes any files found in the lost+found directory of the mount point. </p>
<p>We should be clearing the lost+found to avoid cruft building up and taking all the space in the loop mount.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mountPoint</td><td>The absolute path to the mounted device, NOT the the location of the lost+found dir. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logTag</td><td>If not empty then a log warning message will be printed containing the name of the file that was deleted and referencing the the string in logTag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d85f5f7e2cd5faa35c1433c5b22f954" name="a7d85f5f7e2cd5faa35c1433c5b22f954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d85f5f7e2cd5faa35c1433c5b22f954">&#9670;&#160;</a></span>createFileIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageHelper::createFileIfNeeded </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>storageSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uid_t&#160;</td>
          <td class="paramname"><em>userId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if file exists, if yes return true, if not try to create it. If success return true, if file don't exist and cannot be created return false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePath</td><td>Path to the file that should exist after this function exits </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">storageSize</td><td>Size of the created image file (in bytes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userId</td><td>The expected user id set in the xattr of the image file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileSystem</td><td>Filesystem of created image file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa358b8c96d45ea245c4fd2fcd6b9ccbf" name="aa358b8c96d45ea245c4fd2fcd6b9ccbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa358b8c96d45ea245c4fd2fcd6b9ccbf">&#9670;&#160;</a></span>deleteRecursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageHelper::deleteRecursive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dirfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>availDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursive function that deletes everything within the supplied directory (as a descriptor). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dirFd</td><td>If specified the path should be relative to to this directory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">availDepth</td><td>Maximal depth of recursion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="ac72452cf3115ac710ccaa79c1054d994" name="ac72452cf3115ac710ccaa79c1054d994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac72452cf3115ac710ccaa79c1054d994">&#9670;&#160;</a></span>getLoopDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string StorageHelper::getLoopDevice </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>backingFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the loop device for a given backing file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">backingFile</td><td>Path of backing file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success a string containing the name of the loop device, empty string on error. </dd></dl>

</div>
</div>
<a id="afc816104c52b9e80211fe4b6eaf3a53a" name="afc816104c52b9e80211fe4b6eaf3a53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc816104c52b9e80211fe4b6eaf3a53a">&#9670;&#160;</a></span>loopDeviceAssociate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StorageHelper::loopDeviceAssociate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fileFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>loopDevPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates a give file descriptor with a loop device. </p>
<p>First the function attempts to get a free loop device, if that succeeds it attaches the supplied file descriptor to it and returns an fd to the loop device and (optionally) writes the path to the loop device in the <em>loopDevPath</em> string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileFd</td><td>An open file descriptor to associate with the loop device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">loopDevPath</td><td>If not null, the method will write the path to the loop device dev node into the string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success returns the open file descriptor to the loop device associated with the file, on failure -1. </dd></dl>

</div>
</div>
<a id="a83f81a359083913d7f2aeb8113c35837" name="a83f81a359083913d7f2aeb8113c35837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f81a359083913d7f2aeb8113c35837">&#9670;&#160;</a></span>openLoopDevice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StorageHelper::openLoopDevice </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>loopDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to open an available loop device. </p>
<p>WARNING this method requires sudo</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">loopDevice</td><td>Loop device name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success a positive file descriptor corresponding to a free loop device, -1 on error. </dd></dl>

</div>
</div>
<a id="a77f0b71f475c655a31bbbf0e6771d150" name="a77f0b71f475c655a31bbbf0e6771d150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f0b71f475c655a31bbbf0e6771d150">&#9670;&#160;</a></span>rmdirContents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageHelper::rmdirContents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dirFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the contents of a directory but leave the actual directory in place. </p>
<p>This is equivalent to the 'rm -rf &lt;dir&gt;/ *' command.</p>
<p>If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the file descriptor dirFd, if dirFd is not supplied then it's relative to the cwd.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function only supports deleting directories with contents that are less than 128 levels deep, this is to avoid running out of file descriptors.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dirFd</td><td>If specified the path should be relative to to this directory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the directory to create.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure.</dd></dl>
<p>This is equivalent to the 'cd &lt;dir&gt;; rm -rf *' command.</p>
<p>If the pathname given in <em>path</em> is relative, then it is interpreted relative to the directory referred to by the file descriptor <em>dirFd</em>, if <em>dirFd</em> is not supplied then it's relative to the cwd.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function only supports deleting directories with contents that are less than 128 levels deep, this is to avoid running out of file descriptors.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dirFd</td><td>If specified the path should be relative to to this directory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the directory to create.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a08602b5aa0f9567bd591ec3b486f3d12" name="a08602b5aa0f9567bd591ec3b486f3d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08602b5aa0f9567bd591ec3b486f3d12">&#9670;&#160;</a></span>rmdirRecursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageHelper::rmdirRecursive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dirFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a directory and all it's contents. </p>
<p>This is equivalent to the 'rm -rf &lt;dir&gt;' command.</p>
<p>If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the file descriptor dirFd, if dirFd is not supplied then it's relative to the cwd.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function only supports deleting directories with contents that are less than 128 levels deep, this is to avoid running out of file descriptors.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dirFd</td><td>If specified the path should be relative to to this directory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the directory to create.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure.</dd></dl>
<p>This is equivalent to the 'rm -rf' command.</p>
<p>If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the file descriptor dirFd, if dirFd is not supplied then it's relative to the cwd.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function only supports deleting directories with contents that are less than 128 levels deep, this is to avoid running out of file descriptors.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dirFd</td><td>If specified the path should be relative to to this directory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the directory to create.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>rdkPlugins/Storage/source/<a class="el" href="StorageHelper_8h_source.html">StorageHelper.h</a></li>
<li>rdkPlugins/Storage/source/<b>StorageHelper.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
