<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dobby: DobbyIpcBus Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Dobby<span id="projectnumber">&#160;3.0</span>
   </div>
   <div id="projectbrief">Dobby “Docker based Thingy” is a tool for managing and running OCI containers using crun</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDobbyIpcBus-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DobbyIpcBus Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Wraps an IPC service object on a given bus.  
 <a href="classDobbyIpcBus.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DobbyIpcBus_8h_source.html">DobbyIpcBus.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDobbyIpcBus_1_1tagServiceChangeEvent.html">tagServiceChangeEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDobbyIpcBus_1_1tagServiceHandler.html">tagServiceHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDobbyIpcBus_1_1tagSignalHandler.html">tagSignalHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1e86d4d6f81596cd826527a7c502b70a" id="r_a1e86d4d6f81596cd826527a7c502b70a"><td class="memItemLeft" align="right" valign="top"><a id="a1e86d4d6f81596cd826527a7c502b70a" name="a1e86d4d6f81596cd826527a7c502b70a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DobbyIpcBus</b> (const std::string &amp;dbusAddress, const std::shared_ptr&lt; <a class="el" href="classAI__IPC_1_1IIpcService.html">AI_IPC::IIpcService</a> &gt; &amp;ipcService)</td></tr>
<tr class="separator:a1e86d4d6f81596cd826527a7c502b70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfc1cca4d2aaa146d45d633ccb73ccb" id="r_a3dfc1cca4d2aaa146d45d633ccb73ccb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#a3dfc1cca4d2aaa146d45d633ccb73ccb">connect</a> (const std::string &amp;<a class="el" href="classDobbyIpcBus.html#a50b5d76a7f2551fdb8f2cbe98e7547b1">address</a>)</td></tr>
<tr class="memdesc:a3dfc1cca4d2aaa146d45d633ccb73ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to connect to the bus at the given address.  <br /></td></tr>
<tr class="separator:a3dfc1cca4d2aaa146d45d633ccb73ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379502c8d8d6cae2e077831ffe35b338" id="r_a379502c8d8d6cae2e077831ffe35b338"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#a379502c8d8d6cae2e077831ffe35b338">disconnect</a> ()</td></tr>
<tr class="memdesc:a379502c8d8d6cae2e077831ffe35b338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply disconnects from the bus.  <br /></td></tr>
<tr class="separator:a379502c8d8d6cae2e077831ffe35b338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b5d76a7f2551fdb8f2cbe98e7547b1" id="r_a50b5d76a7f2551fdb8f2cbe98e7547b1"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#a50b5d76a7f2551fdb8f2cbe98e7547b1">address</a> () const</td></tr>
<tr class="memdesc:a50b5d76a7f2551fdb8f2cbe98e7547b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply returns the dbus address if we have one.  <br /></td></tr>
<tr class="separator:a50b5d76a7f2551fdb8f2cbe98e7547b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dfb20cb08862b1bfbe46e636521de8" id="r_ac4dfb20cb08862b1bfbe46e636521de8"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#ac4dfb20cb08862b1bfbe46e636521de8">socketPath</a> () const</td></tr>
<tr class="memdesc:ac4dfb20cb08862b1bfbe46e636521de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns just the socket path of the dbus address.  <br /></td></tr>
<tr class="separator:ac4dfb20cb08862b1bfbe46e636521de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bd9073848365ca6ea407678c7f29d5" id="r_ae7bd9073848365ca6ea407678c7f29d5"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classAI__IPC_1_1IAsyncReplyGetter.html">AI_IPC::IAsyncReplyGetter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#ae7bd9073848365ca6ea407678c7f29d5">invokeMethod</a> (const <a class="el" href="structAI__IPC_1_1Method.html">AI_IPC::Method</a> &amp;method, const AI_IPC::VariantList &amp;args, int timeoutMs) const</td></tr>
<tr class="memdesc:ae7bd9073848365ca6ea407678c7f29d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the ipc method.  <br /></td></tr>
<tr class="separator:ae7bd9073848365ca6ea407678c7f29d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e52e7704885b1e1a8a0af76c675f273" id="r_a1e52e7704885b1e1a8a0af76c675f273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#a1e52e7704885b1e1a8a0af76c675f273">invokeMethod</a> (const <a class="el" href="structAI__IPC_1_1Method.html">AI_IPC::Method</a> &amp;method, const AI_IPC::VariantList &amp;args, AI_IPC::VariantList &amp;replyArgs) const</td></tr>
<tr class="memdesc:a1e52e7704885b1e1a8a0af76c675f273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes the ipc method.  <br /></td></tr>
<tr class="separator:a1e52e7704885b1e1a8a0af76c675f273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a831cde8ad722b6394f4cb3636c2609" id="r_a9a831cde8ad722b6394f4cb3636c2609"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#a9a831cde8ad722b6394f4cb3636c2609">emitSignal</a> (const <a class="el" href="structAI__IPC_1_1Signal.html">AI_IPC::Signal</a> &amp;signal, const AI_IPC::VariantList &amp;args) const</td></tr>
<tr class="memdesc:a9a831cde8ad722b6394f4cb3636c2609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends out a signal over dbus.  <br /></td></tr>
<tr class="separator:a9a831cde8ad722b6394f4cb3636c2609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc5f77558b1b3dfc00b05d736a8b9eb" id="r_a1bc5f77558b1b3dfc00b05d736a8b9eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#a1bc5f77558b1b3dfc00b05d736a8b9eb">serviceAvailable</a> (const std::string &amp;serviceName) const</td></tr>
<tr class="memdesc:a1bc5f77558b1b3dfc00b05d736a8b9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries if the given service is available on the bus.  <br /></td></tr>
<tr class="separator:a1bc5f77558b1b3dfc00b05d736a8b9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac00c17780a583afc5ee7f0ae1b9966c" id="r_aac00c17780a583afc5ee7f0ae1b9966c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#aac00c17780a583afc5ee7f0ae1b9966c">registerServiceHandler</a> (const std::string &amp;serviceName, const ServiceHandlerFn &amp;handlerFunc)</td></tr>
<tr class="memdesc:aac00c17780a583afc5ee7f0ae1b9966c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback function that will be called when the given service is added or removed from the bus.  <br /></td></tr>
<tr class="separator:aac00c17780a583afc5ee7f0ae1b9966c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cfc12ca6f7613bf967341a9dc7e94b" id="r_a70cfc12ca6f7613bf967341a9dc7e94b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#a70cfc12ca6f7613bf967341a9dc7e94b">registerSignalHandler</a> (const <a class="el" href="structAI__IPC_1_1Signal.html">AI_IPC::Signal</a> &amp;signal, const AI_IPC::SignalHandler &amp;handlerFunc)</td></tr>
<tr class="memdesc:a70cfc12ca6f7613bf967341a9dc7e94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback function that will be called when the given signal is received on the bus.  <br /></td></tr>
<tr class="separator:a70cfc12ca6f7613bf967341a9dc7e94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80ae5df2ebc88877b2e9fda42458635" id="r_ae80ae5df2ebc88877b2e9fda42458635"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#ae80ae5df2ebc88877b2e9fda42458635">unregisterHandler</a> (int handlerId)</td></tr>
<tr class="memdesc:ae80ae5df2ebc88877b2e9fda42458635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a signal or service handler.  <br /></td></tr>
<tr class="separator:ae80ae5df2ebc88877b2e9fda42458635"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a8bfe717e4edd97677d09dba97fcc7a0c" id="r_a8bfe717e4edd97677d09dba97fcc7a0c"><td class="memItemLeft" align="right" valign="top"><a id="a8bfe717e4edd97677d09dba97fcc7a0c" name="a8bfe717e4edd97677d09dba97fcc7a0c"></a>
typedef struct <a class="el" href="structDobbyIpcBus_1_1tagServiceHandler.html">DobbyIpcBus::tagServiceHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ServiceHandler</b></td></tr>
<tr class="separator:a8bfe717e4edd97677d09dba97fcc7a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce3642f71f08a6b3dfe18a5a30692fd" id="r_afce3642f71f08a6b3dfe18a5a30692fd"><td class="memItemLeft" align="right" valign="top"><a id="afce3642f71f08a6b3dfe18a5a30692fd" name="afce3642f71f08a6b3dfe18a5a30692fd"></a>
typedef struct <a class="el" href="structDobbyIpcBus_1_1tagSignalHandler.html">DobbyIpcBus::tagSignalHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SignalHandler</b></td></tr>
<tr class="separator:afce3642f71f08a6b3dfe18a5a30692fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205cc745a7ac35926c090ab5b6b00bf4" id="r_a205cc745a7ac35926c090ab5b6b00bf4"><td class="memItemLeft" align="right" valign="top"><a id="a205cc745a7ac35926c090ab5b6b00bf4" name="a205cc745a7ac35926c090ab5b6b00bf4"></a>
typedef struct <a class="el" href="structDobbyIpcBus_1_1tagServiceChangeEvent.html">DobbyIpcBus::tagServiceChangeEvent</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ServiceChangeEvent</b></td></tr>
<tr class="separator:a205cc745a7ac35926c090ab5b6b00bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a686e280fb77243e6f8c763a63150e894" id="r_a686e280fb77243e6f8c763a63150e894"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#a686e280fb77243e6f8c763a63150e894">disconnectNoLock</a> ()</td></tr>
<tr class="memdesc:a686e280fb77243e6f8c763a63150e894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnects the service from the bus.  <br /></td></tr>
<tr class="separator:a686e280fb77243e6f8c763a63150e894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3a5fc67bbcb6f82df7909ca44dfdcf" id="r_a3d3a5fc67bbcb6f82df7909ca44dfdcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#a3d3a5fc67bbcb6f82df7909ca44dfdcf">registerServiceWatcher</a> ()</td></tr>
<tr class="memdesc:a3d3a5fc67bbcb6f82df7909ca44dfdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a signal handler to detect services arriving / leaving the bus.  <br /></td></tr>
<tr class="separator:a3d3a5fc67bbcb6f82df7909ca44dfdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c7f5d3001c80947ee4871b76440d52" id="r_ad2c7f5d3001c80947ee4871b76440d52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#ad2c7f5d3001c80947ee4871b76440d52">serviceNameChanged</a> (const AI_IPC::VariantList &amp;args)</td></tr>
<tr class="memdesc:ad2c7f5d3001c80947ee4871b76440d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function called when dbus has informed us that a name on the bus has changed.  <br /></td></tr>
<tr class="separator:ad2c7f5d3001c80947ee4871b76440d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10353aae308fb3fbf8f799d37b4f0620" id="r_a10353aae308fb3fbf8f799d37b4f0620"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#a10353aae308fb3fbf8f799d37b4f0620">serviceChangeThread</a> ()</td></tr>
<tr class="memdesc:a10353aae308fb3fbf8f799d37b4f0620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread function that receives notifications on service changes and then calls the install handler.  <br /></td></tr>
<tr class="separator:a10353aae308fb3fbf8f799d37b4f0620"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:adbcd601f9b19bdf57b9b6f24cd4aff74" id="r_adbcd601f9b19bdf57b9b6f24cd4aff74"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDobbyIpcBus.html#adbcd601f9b19bdf57b9b6f24cd4aff74">socketPathFromAddress</a> (const std::string &amp;<a class="el" href="classDobbyIpcBus.html#a50b5d76a7f2551fdb8f2cbe98e7547b1">address</a>)</td></tr>
<tr class="memdesc:adbcd601f9b19bdf57b9b6f24cd4aff74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to extract the socket path from the dbus address string.  <br /></td></tr>
<tr class="separator:adbcd601f9b19bdf57b9b6f24cd4aff74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:afb8507806a41e705fd44138fc0816337" id="r_afb8507806a41e705fd44138fc0816337"><td class="memItemLeft" align="right" valign="top"><a id="afb8507806a41e705fd44138fc0816337" name="afb8507806a41e705fd44138fc0816337"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>mLock</b></td></tr>
<tr class="separator:afb8507806a41e705fd44138fc0816337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe637c0442429eee39639b409eb4aa39" id="r_afe637c0442429eee39639b409eb4aa39"><td class="memItemLeft" align="right" valign="top"><a id="afe637c0442429eee39639b409eb4aa39" name="afe637c0442429eee39639b409eb4aa39"></a>
std::shared_ptr&lt; <a class="el" href="classAI__IPC_1_1IIpcService.html">AI_IPC::IIpcService</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mService</b></td></tr>
<tr class="separator:afe637c0442429eee39639b409eb4aa39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78a50f87dc541e35b11ca9891fc0372" id="r_ae78a50f87dc541e35b11ca9891fc0372"><td class="memItemLeft" align="right" valign="top"><a id="ae78a50f87dc541e35b11ca9891fc0372" name="ae78a50f87dc541e35b11ca9891fc0372"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>mDbusAddress</b></td></tr>
<tr class="separator:ae78a50f87dc541e35b11ca9891fc0372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be667dfc2a9b674f64129e8e4305709" id="r_a5be667dfc2a9b674f64129e8e4305709"><td class="memItemLeft" align="right" valign="top"><a id="a5be667dfc2a9b674f64129e8e4305709" name="a5be667dfc2a9b674f64129e8e4305709"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>mDbusSocketPath</b></td></tr>
<tr class="separator:a5be667dfc2a9b674f64129e8e4305709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25da086ddccf577aa03f651fd74b966f" id="r_a25da086ddccf577aa03f651fd74b966f"><td class="memItemLeft" align="right" valign="top"><a id="a25da086ddccf577aa03f651fd74b966f" name="a25da086ddccf577aa03f651fd74b966f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mHandlerId</b></td></tr>
<tr class="separator:a25da086ddccf577aa03f651fd74b966f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ab954cfdcdf5e23faaea0ed7bb3c1a" id="r_ae9ab954cfdcdf5e23faaea0ed7bb3c1a"><td class="memItemLeft" align="right" valign="top"><a id="ae9ab954cfdcdf5e23faaea0ed7bb3c1a" name="ae9ab954cfdcdf5e23faaea0ed7bb3c1a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>mServiceSignal</b></td></tr>
<tr class="separator:ae9ab954cfdcdf5e23faaea0ed7bb3c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e95a2620bf5ed07133be08692251488" id="r_a7e95a2620bf5ed07133be08692251488"><td class="memItemLeft" align="right" valign="top"><a id="a7e95a2620bf5ed07133be08692251488" name="a7e95a2620bf5ed07133be08692251488"></a>
std::map&lt; int, <a class="el" href="structDobbyIpcBus_1_1tagServiceHandler.html">ServiceHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mServiceHandlers</b></td></tr>
<tr class="separator:a7e95a2620bf5ed07133be08692251488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95791003168c9aee5e824d740e78873" id="r_ad95791003168c9aee5e824d740e78873"><td class="memItemLeft" align="right" valign="top"><a id="ad95791003168c9aee5e824d740e78873" name="ad95791003168c9aee5e824d740e78873"></a>
std::map&lt; int, <a class="el" href="structDobbyIpcBus_1_1tagSignalHandler.html">SignalHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mSignalHandlers</b></td></tr>
<tr class="separator:ad95791003168c9aee5e824d740e78873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58ffcfb4fa7baea8513bee1ff6b0706" id="r_ab58ffcfb4fa7baea8513bee1ff6b0706"><td class="memItemLeft" align="right" valign="top"><a id="ab58ffcfb4fa7baea8513bee1ff6b0706" name="ab58ffcfb4fa7baea8513bee1ff6b0706"></a>
std::thread&#160;</td><td class="memItemRight" valign="bottom"><b>mServiceChangeThread</b></td></tr>
<tr class="separator:ab58ffcfb4fa7baea8513bee1ff6b0706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269147c9796ffcb6e683043f890fe969" id="r_a269147c9796ffcb6e683043f890fe969"><td class="memItemLeft" align="right" valign="top"><a id="a269147c9796ffcb6e683043f890fe969" name="a269147c9796ffcb6e683043f890fe969"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>mServiceChangeLock</b></td></tr>
<tr class="separator:a269147c9796ffcb6e683043f890fe969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77219348167bf32eb6fa13fbec8f7520" id="r_a77219348167bf32eb6fa13fbec8f7520"><td class="memItemLeft" align="right" valign="top"><a id="a77219348167bf32eb6fa13fbec8f7520" name="a77219348167bf32eb6fa13fbec8f7520"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><b>mServiceChangeCond</b></td></tr>
<tr class="separator:a77219348167bf32eb6fa13fbec8f7520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b29127f0ec82be27e9a8e29ea39d56" id="r_a91b29127f0ec82be27e9a8e29ea39d56"><td class="memItemLeft" align="right" valign="top"><a id="a91b29127f0ec82be27e9a8e29ea39d56" name="a91b29127f0ec82be27e9a8e29ea39d56"></a>
std::deque&lt; <a class="el" href="structDobbyIpcBus_1_1tagServiceChangeEvent.html">ServiceChangeEvent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mServiceChangeQueue</b></td></tr>
<tr class="separator:a91b29127f0ec82be27e9a8e29ea39d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wraps an IPC service object on a given bus. </p>
<p>This class is a helper for the <a class="el" href="classDobbyUtils.html" title="Utility methods for hooks and the general containiser daemon.">DobbyUtils</a>. It is used to manage a connection to a dbus so that plugins don't need to do the heavy lifting.</p>
<p>For example these objects allow for the bus coming and going, and for managing multiple clients of the bus. It is possible for the bus address to be changed and the clients won't notice or have to re-register their handlers.</p>
<p>This class is not intended to replace the <a class="el" href="classIpcService.html">IpcService</a> class, in fact it relies on it quite heavily, rather it is intended to manage that class for multiple clients. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a50b5d76a7f2551fdb8f2cbe98e7547b1" name="a50b5d76a7f2551fdb8f2cbe98e7547b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b5d76a7f2551fdb8f2cbe98e7547b1">&#9670;&#160;</a></span>address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; DobbyIpcBus::address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply returns the dbus address if we have one. </p>
<p>If not currently connected to a service this will return an empty string. </p>

</div>
</div>
<a id="a3dfc1cca4d2aaa146d45d633ccb73ccb" name="a3dfc1cca4d2aaa146d45d633ccb73ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dfc1cca4d2aaa146d45d633ccb73ccb">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyIpcBus::connect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dbusAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to connect to the bus at the given address. </p>
<p>This method will close any existing connection first before trying to to connect to the new address. If the method fails to connect to the new bus the old connection is not restored, the bus will be left in the disconnected state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dbusAddress</td><td>The dbus address to connect to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if managed to connect to the bus, otherwise false. </dd></dl>

</div>
</div>
<a id="a379502c8d8d6cae2e077831ffe35b338" name="a379502c8d8d6cae2e077831ffe35b338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379502c8d8d6cae2e077831ffe35b338">&#9670;&#160;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyIpcBus::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simply disconnects from the bus. </p>
<p>If there were any service notifiers installed they will each get a 'service left' callback (provided the bus was actually connected). </p>

</div>
</div>
<a id="a686e280fb77243e6f8c763a63150e894" name="a686e280fb77243e6f8c763a63150e894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686e280fb77243e6f8c763a63150e894">&#9670;&#160;</a></span>disconnectNoLock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyIpcBus::disconnectNoLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disconnects the service from the bus. </p>
<p>This will call any service notifiers to tell them that their interested service(s) has left the bus. Obviously this may not actually be true, but since we're closing our connection to the bus it might as well be because there is no way to now talk to those services.</p>
<p>It then flushes out all messages and removes the signal notifier. </p>

</div>
</div>
<a id="a9a831cde8ad722b6394f4cb3636c2609" name="a9a831cde8ad722b6394f4cb3636c2609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a831cde8ad722b6394f4cb3636c2609">&#9670;&#160;</a></span>emitSignal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyIpcBus::emitSignal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAI__IPC_1_1Signal.html">AI_IPC::Signal</a> &amp;&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AI_IPC::VariantList &amp;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends out a signal over dbus. </p>
<p>This is a pure wrapper around the <a class="el" href="classIpcService.html#af9962a553561ec2605aa21304804ff0c" title="Emit a signal.">IpcService::emitSignal</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>The signal details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The signal args.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="a1e52e7704885b1e1a8a0af76c675f273" name="a1e52e7704885b1e1a8a0af76c675f273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e52e7704885b1e1a8a0af76c675f273">&#9670;&#160;</a></span>invokeMethod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyIpcBus::invokeMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAI__IPC_1_1Method.html">AI_IPC::Method</a> &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AI_IPC::VariantList &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AI_IPC::VariantList &amp;&#160;</td>
          <td class="paramname"><em>replyArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the ipc method. </p>
<p>This is a pure wrapper around the <a class="el" href="classIpcService.html#af342303de84e188a478fd7721cb4e930" title="Invoke a method and get reply asynchronously.">IpcService::invokeMethod</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>The method to call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The method args </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">replyArgs</td><td>The reply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a id="ae7bd9073848365ca6ea407678c7f29d5" name="ae7bd9073848365ca6ea407678c7f29d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bd9073848365ca6ea407678c7f29d5">&#9670;&#160;</a></span>invokeMethod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classAI__IPC_1_1IAsyncReplyGetter.html">AI_IPC::IAsyncReplyGetter</a> &gt; DobbyIpcBus::invokeMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAI__IPC_1_1Method.html">AI_IPC::Method</a> &amp;&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AI_IPC::VariantList &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invokes the ipc method. </p>
<p>This is a pure wrapper around the <a class="el" href="classIpcService.html#af342303de84e188a478fd7721cb4e930" title="Invoke a method and get reply asynchronously.">IpcService::invokeMethod</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>The method to call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The method args </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMs</td><td>Timeout in milliseconds, -1 for default (5 seconds)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A result to wait on. </dd></dl>

</div>
</div>
<a id="aac00c17780a583afc5ee7f0ae1b9966c" name="aac00c17780a583afc5ee7f0ae1b9966c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac00c17780a583afc5ee7f0ae1b9966c">&#9670;&#160;</a></span>registerServiceHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DobbyIpcBus::registerServiceHandler </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>serviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ServiceHandlerFn &amp;&#160;</td>
          <td class="paramname"><em>handlerFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback function that will be called when the given service is added or removed from the bus. </p>
<p>This in turn is useful for hooks to manage situations where the daemon they are talking to has crashed / restarted.</p>
<p>Case in point is the Jumper hook, it wants to know if the daemon has crashed so it doesn't block container startup by trying to talk to a nonexisting daemon. And likewise it wants to know when it's arrived back so it can re-create any state stored in the daemon.</p>
<p>To remove the handler call <em>ipcUnregisterHandler</em> with the handler id returned by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">serviceName</td><td>The name of the service to look out for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerFunc</td><td>Callback function called when the service is added or removed. If added the argument supplied will be true, if removed it will be false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the notifier is successifully added then a positive handler id will be returned, otherwise -1 </dd></dl>

</div>
</div>
<a id="a3d3a5fc67bbcb6f82df7909ca44dfdcf" name="a3d3a5fc67bbcb6f82df7909ca44dfdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3a5fc67bbcb6f82df7909ca44dfdcf">&#9670;&#160;</a></span>registerServiceWatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyIpcBus::registerServiceWatcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Install a signal handler to detect services arriving / leaving the bus. </p>
<p>Installs a signal listener for the 'org.freedesktop.DBus.NameOwnerChanged' signal which is used to tell when services arrive and leave the bus, we use it to implement the DobbyUtils::ipcServiceNotify() method</p>
<p>The method updates the <em>mNotifierSignal</em> internal string to hold the the registered handler. It is assumed that the handler is not already installed. </p>

</div>
</div>
<a id="a70cfc12ca6f7613bf967341a9dc7e94b" name="a70cfc12ca6f7613bf967341a9dc7e94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cfc12ca6f7613bf967341a9dc7e94b">&#9670;&#160;</a></span>registerSignalHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DobbyIpcBus::registerSignalHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAI__IPC_1_1Signal.html">AI_IPC::Signal</a> &amp;&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AI_IPC::SignalHandler &amp;&#160;</td>
          <td class="paramname"><em>handlerFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback function that will be called when the given signal is received on the bus. </p>
<p>This is a pure wrapper around the <a class="el" href="classIpcService.html#abb2f3e3e96d5b4e272c56f739973950f" title="Register a signal handler.">IpcService.registerSignalHandler</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>The signal details to watch for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerFunc</td><td>Callback function called when the signal is received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if the handler is successifully added then a positive handler id will be returned, otherwise -1 </dd></dl>

</div>
</div>
<a id="a1bc5f77558b1b3dfc00b05d736a8b9eb" name="a1bc5f77558b1b3dfc00b05d736a8b9eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc5f77558b1b3dfc00b05d736a8b9eb">&#9670;&#160;</a></span>serviceAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DobbyIpcBus::serviceAvailable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>serviceName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries if the given service is available on the bus. </p>
<p>This is a pure wrapper around the IpcService::serviceAvailable function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">serviceName</td><td>The service to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the service is available, otherwise false. </dd></dl>

</div>
</div>
<a id="a10353aae308fb3fbf8f799d37b4f0620" name="a10353aae308fb3fbf8f799d37b4f0620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10353aae308fb3fbf8f799d37b4f0620">&#9670;&#160;</a></span>serviceChangeThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyIpcBus::serviceChangeThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread function that receives notifications on service changes and then calls the install handler. </p>
<p>We use a separate thread to notify of signal changes because we don't want to block the <a class="el" href="classIpcService.html">IpcService</a> thread for long periods of time while plugins setup / teardown their IPC code. </p>

</div>
</div>
<a id="ad2c7f5d3001c80947ee4871b76440d52" name="ad2c7f5d3001c80947ee4871b76440d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c7f5d3001c80947ee4871b76440d52">&#9670;&#160;</a></span>serviceNameChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyIpcBus::serviceNameChanged </td>
          <td>(</td>
          <td class="paramtype">const AI_IPC::VariantList &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback function called when dbus has informed us that a name on the bus has changed. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://dbus.freedesktop.org/doc/dbus-specification.html#bus-messages-name-owner-changed">https://dbus.freedesktop.org/doc/dbus-specification.html#bus-messages-name-owner-changed</a></dd></dl>
<p>We use this signal to notify any listeners (typically hooks) that a service has arrived or left the bus. This in turn is useful for hooks to manage situations where the daemon they are talking to has crashed / restarted.</p>
<p>Case in point is the Jumper hook, it wants to know if the daemon has crashed so it doesn't block container startup trying to talk to non-existing daemon. And likewise it wants to know when it's arrived back so it can re-create any state stored in the daemon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The args received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4dfb20cb08862b1bfbe46e636521de8" name="ac4dfb20cb08862b1bfbe46e636521de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dfb20cb08862b1bfbe46e636521de8">&#9670;&#160;</a></span>socketPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; DobbyIpcBus::socketPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns just the socket path of the dbus address. </p>
<p>If not currently connected to a service this will return an empty string. </p>

</div>
</div>
<a id="adbcd601f9b19bdf57b9b6f24cd4aff74" name="adbcd601f9b19bdf57b9b6f24cd4aff74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcd601f9b19bdf57b9b6f24cd4aff74">&#9670;&#160;</a></span>socketPathFromAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string DobbyIpcBus::socketPathFromAddress </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to extract the socket path from the dbus address string. </p>
<p>This uses the low level dbus library API to parse the address and extract the fields. If the address supplied is not a unix socket then an empty string is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The dbus address trying to parse</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success the path to the dbus socket, on failure an empty string. </dd></dl>

</div>
</div>
<a id="ae80ae5df2ebc88877b2e9fda42458635" name="ae80ae5df2ebc88877b2e9fda42458635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80ae5df2ebc88877b2e9fda42458635">&#9670;&#160;</a></span>unregisterHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DobbyIpcBus::unregisterHandler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>handlerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a signal or service handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerId</td><td>The handler id returned by either the registerSignalHandler or registerServiceHandler methods. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>ipcUtils/include/<a class="el" href="DobbyIpcBus_8h_source.html">DobbyIpcBus.h</a></li>
<li>ipcUtils/source/<b>DobbyIpcBus.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
