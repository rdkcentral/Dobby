<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dobby: Netlink Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dobby
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">Dobby “Docker based Thingy” is a tool for managing and running OCI containers using crun</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classNetlink-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Netlink Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic wrapper around the libnl netlink library.  
 <a href="classNetlink.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Netlink_8h_source.html">Netlink.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNetlink_1_1BridgePortDetails.html">BridgePortDetails</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5406db0499fb2095552447db8e524038"><td class="memItemLeft" align="right" valign="top"><a id="a5406db0499fb2095552447db8e524038"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValid</b> () const</td></tr>
<tr class="separator:a5406db0499fb2095552447db8e524038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a74c8df61e0a85baea18835d60b00b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a52a74c8df61e0a85baea18835d60b00b">ifaceUp</a> (const std::string &amp;ifaceName)</td></tr>
<tr class="memdesc:a52a74c8df61e0a85baea18835d60b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brings an interface up.  <a href="classNetlink.html#a52a74c8df61e0a85baea18835d60b00b">More...</a><br /></td></tr>
<tr class="separator:a52a74c8df61e0a85baea18835d60b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39f6cb4c6822c78b05cff34170786ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#af39f6cb4c6822c78b05cff34170786ef">ifaceDown</a> (const std::string &amp;ifaceName)</td></tr>
<tr class="memdesc:af39f6cb4c6822c78b05cff34170786ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an interface down.  <a href="classNetlink.html#af39f6cb4c6822c78b05cff34170786ef">More...</a><br /></td></tr>
<tr class="separator:af39f6cb4c6822c78b05cff34170786ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2089086d94ce1f09148f14b31111db45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a2089086d94ce1f09148f14b31111db45">ifaceIsUp</a> (const std::string &amp;ifaceName) const</td></tr>
<tr class="memdesc:a2089086d94ce1f09148f14b31111db45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the interface to determine if it's up or not.  <a href="classNetlink.html#a2089086d94ce1f09148f14b31111db45">More...</a><br /></td></tr>
<tr class="separator:a2089086d94ce1f09148f14b31111db45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eea307df469a193fb36640bdc1f8752"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a1eea307df469a193fb36640bdc1f8752">ifaceExists</a> (const std::string &amp;ifaceName) const</td></tr>
<tr class="memdesc:a1eea307df469a193fb36640bdc1f8752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an interface with a given name exists (interface could be either up or down)  <a href="classNetlink.html#a1eea307df469a193fb36640bdc1f8752">More...</a><br /></td></tr>
<tr class="separator:a1eea307df469a193fb36640bdc1f8752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629dff84775d89b129f946b8d990e446"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a629dff84775d89b129f946b8d990e446">setIfaceAddress</a> (const std::string &amp;ifaceName, const in_addr_t address, const in_addr_t netmask)</td></tr>
<tr class="memdesc:a629dff84775d89b129f946b8d990e446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ip address and netmask of an interface (IPv4)  <a href="classNetlink.html#a629dff84775d89b129f946b8d990e446">More...</a><br /></td></tr>
<tr class="separator:a629dff84775d89b129f946b8d990e446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d972ece987eba5ce9f8574686dd282"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a16d972ece987eba5ce9f8574686dd282">setIfaceAddress</a> (const std::string &amp;ifaceName, const struct in6_addr address, const int netmask)</td></tr>
<tr class="memdesc:a16d972ece987eba5ce9f8574686dd282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ip address and netmask of an interface (IPv6)  <a href="classNetlink.html#a16d972ece987eba5ce9f8574686dd282">More...</a><br /></td></tr>
<tr class="separator:a16d972ece987eba5ce9f8574686dd282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fde096f6fe4d6909397acb2c547094"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#af3fde096f6fe4d6909397acb2c547094">setIfaceForwarding</a> (const std::string &amp;ifaceName, bool enable)</td></tr>
<tr class="memdesc:af3fde096f6fe4d6909397acb2c547094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables IPv4 forwarding on the given interface.  <a href="classNetlink.html#af3fde096f6fe4d6909397acb2c547094">More...</a><br /></td></tr>
<tr class="separator:af3fde096f6fe4d6909397acb2c547094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae1902e0f4472279348a4219bb876f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a2ae1902e0f4472279348a4219bb876f6">setIfaceForwarding6</a> (const std::shared_ptr&lt; <a class="el" href="classDobbyRdkPluginUtils.html">DobbyRdkPluginUtils</a> &gt; &amp;utils, const std::string &amp;ifaceName, bool enable)</td></tr>
<tr class="memdesc:a2ae1902e0f4472279348a4219bb876f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables IPv6 forwarding on the given interface.  <a href="classNetlink.html#a2ae1902e0f4472279348a4219bb876f6">More...</a><br /></td></tr>
<tr class="separator:a2ae1902e0f4472279348a4219bb876f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587c8e52226e91be670fb4be904466a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a587c8e52226e91be670fb4be904466a6">setIfaceRouteLocalNet</a> (const std::string &amp;ifaceName, bool enable)</td></tr>
<tr class="memdesc:a587c8e52226e91be670fb4be904466a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the route_localnet flag on the interface.  <a href="classNetlink.html#a587c8e52226e91be670fb4be904466a6">More...</a><br /></td></tr>
<tr class="separator:a587c8e52226e91be670fb4be904466a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cacaae8639c8882ed3bda348c9fb72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#ab6cacaae8639c8882ed3bda348c9fb72">setIfaceAcceptRa</a> (const std::shared_ptr&lt; <a class="el" href="classDobbyRdkPluginUtils.html">DobbyRdkPluginUtils</a> &gt; &amp;utils, const std::string &amp;ifaceName, int value)</td></tr>
<tr class="memdesc:ab6cacaae8639c8882ed3bda348c9fb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the accept_ra flag on the interface.  <a href="classNetlink.html#ab6cacaae8639c8882ed3bda348c9fb72">More...</a><br /></td></tr>
<tr class="separator:ab6cacaae8639c8882ed3bda348c9fb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05958a0f8cb0136b257193e811daaf5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#ad05958a0f8cb0136b257193e811daaf5">setIfaceMAC</a> (const std::string &amp;ifaceName, const std::array&lt; uint8_t, 6 &gt; &amp;address)</td></tr>
<tr class="memdesc:ad05958a0f8cb0136b257193e811daaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the MAC address of the given interface.  <a href="classNetlink.html#ad05958a0f8cb0136b257193e811daaf5">More...</a><br /></td></tr>
<tr class="separator:ad05958a0f8cb0136b257193e811daaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af912288cf12c6c0c9a61ccb5b9157f90"><td class="memItemLeft" align="right" valign="top">std::array&lt; uint8_t, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#af912288cf12c6c0c9a61ccb5b9157f90">getIfaceMAC</a> (const std::string &amp;ifaceName)</td></tr>
<tr class="memdesc:af912288cf12c6c0c9a61ccb5b9157f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the MAC address of the given interface.  <a href="classNetlink.html#af912288cf12c6c0c9a61ccb5b9157f90">More...</a><br /></td></tr>
<tr class="separator:af912288cf12c6c0c9a61ccb5b9157f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b45871f8f3fe9519ccb7ed365e99ac1"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="structNetlink_1_1BridgePortDetails.html">BridgePortDetails</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a9b45871f8f3fe9519ccb7ed365e99ac1">getAttachedIfaces</a> (const std::string &amp;bridgeName)</td></tr>
<tr class="memdesc:a9b45871f8f3fe9519ccb7ed365e99ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of interfaces currently enslaved to a given bridge device.  <a href="classNetlink.html#a9b45871f8f3fe9519ccb7ed365e99ac1">More...</a><br /></td></tr>
<tr class="separator:a9b45871f8f3fe9519ccb7ed365e99ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1092d84598f32a36554d0a504fee720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#ab1092d84598f32a36554d0a504fee720">createBridge</a> (const std::string &amp;bridgeName)</td></tr>
<tr class="memdesc:ab1092d84598f32a36554d0a504fee720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new bridge device.  <a href="classNetlink.html#ab1092d84598f32a36554d0a504fee720">More...</a><br /></td></tr>
<tr class="separator:ab1092d84598f32a36554d0a504fee720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e1f8c0d7a62f3d8deab7ef365d6427"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#ac3e1f8c0d7a62f3d8deab7ef365d6427">destroyBridge</a> (const std::string &amp;bridgeName)</td></tr>
<tr class="memdesc:ac3e1f8c0d7a62f3d8deab7ef365d6427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes an existing bridge device.  <a href="classNetlink.html#ac3e1f8c0d7a62f3d8deab7ef365d6427">More...</a><br /></td></tr>
<tr class="separator:ac3e1f8c0d7a62f3d8deab7ef365d6427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d817257f63f023cc99be47138befc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a68d817257f63f023cc99be47138befc7">addIfaceToBridge</a> (const std::string &amp;bridgeName, const std::string &amp;ifaceName)</td></tr>
<tr class="memdesc:a68d817257f63f023cc99be47138befc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an interface to the bridge device.  <a href="classNetlink.html#a68d817257f63f023cc99be47138befc7">More...</a><br /></td></tr>
<tr class="separator:a68d817257f63f023cc99be47138befc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538c4e7a168082e74015f8816c8b6b8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a538c4e7a168082e74015f8816c8b6b8a">delIfaceFromBridge</a> (const std::string &amp;bridgeName, const std::string &amp;ifaceName)</td></tr>
<tr class="memdesc:a538c4e7a168082e74015f8816c8b6b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an interface from a bridge.  <a href="classNetlink.html#a538c4e7a168082e74015f8816c8b6b8a">More...</a><br /></td></tr>
<tr class="separator:a538c4e7a168082e74015f8816c8b6b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e40b21b2e8f09a164914cebe4e3823"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#ab3e40b21b2e8f09a164914cebe4e3823">createVeth</a> (const std::string &amp;peerVethName, pid_t peerPid, std::vector&lt; std::string &gt; &amp;takenVeths)</td></tr>
<tr class="memdesc:ab3e40b21b2e8f09a164914cebe4e3823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a veth pair for the netns attached to the given pid.  <a href="classNetlink.html#ab3e40b21b2e8f09a164914cebe4e3823">More...</a><br /></td></tr>
<tr class="separator:ab3e40b21b2e8f09a164914cebe4e3823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9075e14700f89200af8e55c4044c9b5d"><td class="memItemLeft" align="right" valign="top"><a id="a9075e14700f89200af8e55c4044c9b5d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkVeth</b> (const std::string &amp;vethName)</td></tr>
<tr class="separator:a9075e14700f89200af8e55c4044c9b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef4373a38877fbecdc6d2705627ba58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a4ef4373a38877fbecdc6d2705627ba58">addRoute</a> (const std::string &amp;iface, const in_addr_t destination, const in_addr_t netmask, const in_addr_t gateway)</td></tr>
<tr class="memdesc:a4ef4373a38877fbecdc6d2705627ba58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new route to the routing table (IPv4)  <a href="classNetlink.html#a4ef4373a38877fbecdc6d2705627ba58">More...</a><br /></td></tr>
<tr class="separator:a4ef4373a38877fbecdc6d2705627ba58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d416a2fc78ba913d27dd69bbf4a718f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a1d416a2fc78ba913d27dd69bbf4a718f">addRoute</a> (const std::string &amp;iface, const struct in6_addr destination, const int netmask, const struct in6_addr gateway)</td></tr>
<tr class="memdesc:a1d416a2fc78ba913d27dd69bbf4a718f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new route to the routing table (IPv6)  <a href="classNetlink.html#a1d416a2fc78ba913d27dd69bbf4a718f">More...</a><br /></td></tr>
<tr class="separator:a1d416a2fc78ba913d27dd69bbf4a718f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af269f9f438b252b8ff49c1a87d1d92f1"><td class="memItemLeft" align="right" valign="top"><a id="af269f9f438b252b8ff49c1a87d1d92f1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>applyChangesToLink</b> (const std::string &amp;ifaceName, const <a class="el" href="classNlLink.html">NlLink</a> &amp;changes)</td></tr>
<tr class="separator:af269f9f438b252b8ff49c1a87d1d92f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3949cb04a9ab5489d4dbcb5e96c501b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a3949cb04a9ab5489d4dbcb5e96c501b1">setLinkAddress</a> (const <a class="el" href="classNlLink.html">NlLink</a> &amp;link, const in_addr_t address, const in_addr_t netmask)</td></tr>
<tr class="memdesc:a3949cb04a9ab5489d4dbcb5e96c501b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ip address and netmask of an interface (IPv4)  <a href="classNetlink.html#a3949cb04a9ab5489d4dbcb5e96c501b1">More...</a><br /></td></tr>
<tr class="separator:a3949cb04a9ab5489d4dbcb5e96c501b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528c41cefc07e00a649a464390d34a42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a528c41cefc07e00a649a464390d34a42">setLinkAddress</a> (const <a class="el" href="classNlLink.html">NlLink</a> &amp;link, const struct in6_addr address, const int netmask)</td></tr>
<tr class="memdesc:a528c41cefc07e00a649a464390d34a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ip address and netmask of an interface (IPv6)  <a href="classNetlink.html#a528c41cefc07e00a649a464390d34a42">More...</a><br /></td></tr>
<tr class="separator:a528c41cefc07e00a649a464390d34a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9022448c646f8fb62cd07e49e8ac7c23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a9022448c646f8fb62cd07e49e8ac7c23">setIfaceConfig</a> (const std::string &amp;ifaceName, const unsigned int configId, const uint32_t value)</td></tr>
<tr class="memdesc:a9022448c646f8fb62cd07e49e8ac7c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the config on a given interface.  <a href="classNetlink.html#a9022448c646f8fb62cd07e49e8ac7c23">More...</a><br /></td></tr>
<tr class="separator:a9022448c646f8fb62cd07e49e8ac7c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903f1170cb3b4999fc79daf82cf12889"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNetlink.html#a903f1170cb3b4999fc79daf82cf12889">getAvailableVethName</a> (const int startIndex) const</td></tr>
<tr class="memdesc:a903f1170cb3b4999fc79daf82cf12889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the next free veth device.  <a href="classNetlink.html#a903f1170cb3b4999fc79daf82cf12889">More...</a><br /></td></tr>
<tr class="separator:a903f1170cb3b4999fc79daf82cf12889"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a20442a31c804aea2a194a4848c86cc0d"><td class="memItemLeft" align="right" valign="top"><a id="a20442a31c804aea2a194a4848c86cc0d"></a>
struct nl_sock *&#160;</td><td class="memItemRight" valign="bottom"><b>mSocket</b></td></tr>
<tr class="separator:a20442a31c804aea2a194a4848c86cc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5788bb80891364c68aec6a4d1c7b3567"><td class="memItemLeft" align="right" valign="top"><a id="a5788bb80891364c68aec6a4d1c7b3567"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mSysClassNetDirFd</b></td></tr>
<tr class="separator:a5788bb80891364c68aec6a4d1c7b3567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc0d513a24e97ecba454714d0630904"><td class="memItemLeft" align="right" valign="top"><a id="affc0d513a24e97ecba454714d0630904"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>mLock</b></td></tr>
<tr class="separator:affc0d513a24e97ecba454714d0630904"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Basic wrapper around the libnl netlink library. </p>
<p>There is only expected to be one of these objects (i.e. a shared_ptr is passed around). The object represents a single netlink socket.</p>
<p>At construction time a new netlink socket is opened, on destruction it is closed. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a68d817257f63f023cc99be47138befc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d817257f63f023cc99be47138befc7">&#9670;&nbsp;</a></span>addIfaceToBridge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::addIfaceToBridge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bridgeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an interface to the bridge device. </p>
<p>This is equivalent of the performing the following on the command line </p><pre class="fragment">brctl addif &lt;bridgeName&gt; &lt;ifaceName&gt;
</pre> <dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a4ef4373a38877fbecdc6d2705627ba58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef4373a38877fbecdc6d2705627ba58">&#9670;&nbsp;</a></span>addRoute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::addRoute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const in_addr_t&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const in_addr_t&#160;</td>
          <td class="paramname"><em>netmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const in_addr_t&#160;</td>
          <td class="paramname"><em>gateway</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new route to the routing table (IPv4) </p>
<p>This is equivalent of the performing the following on the command line </p><pre class="fragment">ip route add &lt;destination&gt;/&lt;netmask&gt; via &lt;gateway&gt; dev &lt;ifname&gt;
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iface</td><td>The name of the iface to route to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>The destination ip address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">netmask</td><td>The netmask for the destination ip address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gateway</td><td>The ip address of the gateway</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a1d416a2fc78ba913d27dd69bbf4a718f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d416a2fc78ba913d27dd69bbf4a718f">&#9670;&nbsp;</a></span>addRoute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::addRoute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct in6_addr&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>netmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct in6_addr&#160;</td>
          <td class="paramname"><em>gateway</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new route to the routing table (IPv6) </p>
<p>This is equivalent of the performing the following on the command line </p><pre class="fragment">ip -6 route add &lt;destination&gt;/&lt;netmask&gt; via &lt;gateway&gt; dev &lt;ifname&gt;
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iface</td><td>The name of the iface to route to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>The destination ip address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">netmask</td><td>The netmask for the destination ip address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gateway</td><td>The ip address of the gateway, if null, we don't set a gateway for the route.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="ab1092d84598f32a36554d0a504fee720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1092d84598f32a36554d0a504fee720">&#9670;&nbsp;</a></span>createBridge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::createBridge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bridgeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new bridge device. </p>
<p>Note that it is not an error if a bridge device already exists with the same name, this method will return true in that case.</p>
<p>This is equivalent of the performing the following on the command line </p><pre class="fragment">brctl addbr &lt;bridgeName&gt;
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bridgeName</td><td>The name of the new bridge device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="ab3e40b21b2e8f09a164914cebe4e3823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e40b21b2e8f09a164914cebe4e3823">&#9670;&nbsp;</a></span>createVeth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Netlink::createVeth </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>peerVethName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>peerPid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>takenVeths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a veth pair for the netns attached to the given pid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">peerVethName</td><td>The name of the veth interface inside the net namespace (container), typically this will be "eth0". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peerPid</td><td>The pid of the process which has the netns we want to create the veth in (i.e. the pid of init process within the container). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">takenVeths</td><td>Veth devices reserved by other containers. We want to check that in case of races.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success the interface name of the veth pair, this is the name outside the container and will be of the form vethd, ie veth0, veth1, etc. On failure an empty string is returned. </dd></dl>

</div>
</div>
<a id="a538c4e7a168082e74015f8816c8b6b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538c4e7a168082e74015f8816c8b6b8a">&#9670;&nbsp;</a></span>delIfaceFromBridge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::delIfaceFromBridge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bridgeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an interface from a bridge. </p>
<p>This is equivalent of the performing the following on the command line </p><pre class="fragment">brctl delif &lt;bridgeName&gt; &lt;ifaceName&gt;
</pre> <dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="ac3e1f8c0d7a62f3d8deab7ef365d6427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e1f8c0d7a62f3d8deab7ef365d6427">&#9670;&nbsp;</a></span>destroyBridge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::destroyBridge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bridgeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes an existing bridge device. </p>
<p>This is equivalent of the performing the following on the command line </p><pre class="fragment">brctl delbr &lt;bridgeName&gt;
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bridgeName</td><td>The name of the new bridge to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a9b45871f8f3fe9519ccb7ed365e99ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b45871f8f3fe9519ccb7ed365e99ac1">&#9670;&nbsp;</a></span>getAttachedIfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="structNetlink_1_1BridgePortDetails.html">Netlink::BridgePortDetails</a> &gt; Netlink::getAttachedIfaces </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>bridgeName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the set of interfaces currently enslaved to a given bridge device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bridgeName</td><td>The name of the bridge device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of interfaces attached to the bridge, or empty list on failure. </dd></dl>

</div>
</div>
<a id="a903f1170cb3b4999fc79daf82cf12889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903f1170cb3b4999fc79daf82cf12889">&#9670;&nbsp;</a></span>getAvailableVethName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Netlink::getAvailableVethName </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>startIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of the next free veth device. </p>
<p>This works by scanning /sys/class/net/ for devices with names "veth%d", the first one not found is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Starting index for veth names</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of a free veth device, if all names are used (possible?) we return an empty string. </dd></dl>

</div>
</div>
<a id="af912288cf12c6c0c9a61ccb5b9157f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af912288cf12c6c0c9a61ccb5b9157f90">&#9670;&nbsp;</a></span>getIfaceMAC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; uint8_t, 6 &gt; Netlink::getIfaceMAC </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the MAC address of the given interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mac address. </dd></dl>

</div>
</div>
<a id="af39f6cb4c6822c78b05cff34170786ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af39f6cb4c6822c78b05cff34170786ef">&#9670;&nbsp;</a></span>ifaceDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::ifaceDown </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes an interface down. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to take down.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a1eea307df469a193fb36640bdc1f8752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eea307df469a193fb36640bdc1f8752">&#9670;&nbsp;</a></span>ifaceExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::ifaceExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an interface with a given name exists (interface could be either up or down) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the interface exists, otherwise false. </dd></dl>

</div>
</div>
<a id="a2089086d94ce1f09148f14b31111db45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2089086d94ce1f09148f14b31111db45">&#9670;&nbsp;</a></span>ifaceIsUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::ifaceIsUp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the interface to determine if it's up or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the interface is up, otherwise false. </dd></dl>

</div>
</div>
<a id="a52a74c8df61e0a85baea18835d60b00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a74c8df61e0a85baea18835d60b00b">&#9670;&nbsp;</a></span>ifaceUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::ifaceUp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Brings an interface up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to bring up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="ab6cacaae8639c8882ed3bda348c9fb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cacaae8639c8882ed3bda348c9fb72">&#9670;&nbsp;</a></span>setIfaceAcceptRa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::setIfaceAcceptRa </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classDobbyRdkPluginUtils.html">DobbyRdkPluginUtils</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>utils</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the accept_ra flag on the interface. </p>
<p>This is the equivalent of the following on the command line </p><pre class="fragment">echo "2" &gt; /proc/sys/net/ipv6/conf/&lt;ifaceName&gt;/accept_ra
</pre><p> Or echo "1" &gt; /proc/sys/net/ipv6/conf/&lt;ifaceName&gt;/accept_ra Or echo "0" &gt; /proc/sys/net/ipv6/conf/&lt;ifaceName&gt;/accept_ra</p>
<p>This is used to set accept_ra to "2" so that router advertisements are accepted on the interface even with forwarding enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utils</td><td>Instance of the <a class="el" href="classDobbyRdkPluginUtils.html" title="Class for useful utility methods for plugins such as adding mounts and environment variables.">DobbyRdkPluginUtils</a> class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to set the config on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>true to enable, false to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a629dff84775d89b129f946b8d990e446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629dff84775d89b129f946b8d990e446">&#9670;&nbsp;</a></span>setIfaceAddress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::setIfaceAddress </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const in_addr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const in_addr_t&#160;</td>
          <td class="paramname"><em>netmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the ip address and netmask of an interface (IPv4) </p>
<p>This is the equivalent of the following on the command line </p><pre class="fragment">ifconfig &lt;ifaceName&gt; &lt;address&gt; netmask &lt;netmask&gt;
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to set the address on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address to set, the netmask will be applied to this before setting on the iface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">netmask</td><td>The netmask to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a16d972ece987eba5ce9f8574686dd282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d972ece987eba5ce9f8574686dd282">&#9670;&nbsp;</a></span>setIfaceAddress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::setIfaceAddress </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct in6_addr&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>netmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the ip address and netmask of an interface (IPv6) </p>
<p>This is the equivalent of the following on the command line </p><pre class="fragment">ifconfig &lt;ifaceName&gt; inet6 add &lt;address&gt;/&lt;netmask&gt;
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to set the address on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The IPv6 address to set, the netmask will be applied to this before setting on the iface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">netmask</td><td>The netmask to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a9022448c646f8fb62cd07e49e8ac7c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9022448c646f8fb62cd07e49e8ac7c23">&#9670;&nbsp;</a></span>setIfaceConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::setIfaceConfig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>configId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the config on a given interface. </p>
<p>Used by <a class="el" href="classNetlink.html#af3fde096f6fe4d6909397acb2c547094" title="Enables or disables IPv4 forwarding on the given interface.">setIfaceForwarding()</a> and <a class="el" href="classNetlink.html#a587c8e52226e91be670fb4be904466a6" title="Sets the route_localnet flag on the interface.">setIfaceRouteLocalNet()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to set the address on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configId</td><td>The config to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="af3fde096f6fe4d6909397acb2c547094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fde096f6fe4d6909397acb2c547094">&#9670;&nbsp;</a></span>setIfaceForwarding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::setIfaceForwarding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables IPv4 forwarding on the given interface. </p>
<p>This is the equivalent of the following on the command line </p><pre class="fragment">echo "1" &gt; /proc/sys/net/ipv4/conf/&lt;ifaceName&gt;/forwarding
</pre><p> Or echo "0" &gt; /proc/sys/net/ipv4/conf/&lt;ifaceName&gt;/forwarding</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to set the config on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>true to enable, false to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a2ae1902e0f4472279348a4219bb876f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae1902e0f4472279348a4219bb876f6">&#9670;&nbsp;</a></span>setIfaceForwarding6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::setIfaceForwarding6 </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classDobbyRdkPluginUtils.html">DobbyRdkPluginUtils</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>utils</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables IPv6 forwarding on the given interface. </p>
<p>This is the equivalent of the following on the command line </p><pre class="fragment">echo "1" &gt; /proc/sys/net/ipv6/conf/&lt;ifaceName&gt;/forwarding
</pre><p> Or echo "0" &gt; /proc/sys/net/ipv6/conf/&lt;ifaceName&gt;/forwarding</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utils</td><td>Instance of the <a class="el" href="classDobbyRdkPluginUtils.html" title="Class for useful utility methods for plugins such as adding mounts and environment variables.">DobbyRdkPluginUtils</a> class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to set the config on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>true to enable, false to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="ad05958a0f8cb0136b257193e811daaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05958a0f8cb0136b257193e811daaf5">&#9670;&nbsp;</a></span>setIfaceMAC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::setIfaceMAC </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; uint8_t, 6 &gt; &amp;&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the MAC address of the given interface. </p>
<p>This is primarily used to set a fixed MAC address for the bridge device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The MAC address to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successfully set. </dd></dl>

</div>
</div>
<a id="a587c8e52226e91be670fb4be904466a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587c8e52226e91be670fb4be904466a6">&#9670;&nbsp;</a></span>setIfaceRouteLocalNet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::setIfaceRouteLocalNet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ifaceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the route_localnet flag on the interface. </p>
<p>Which means: "Do not consider loopback addresses as martian source or destination while routing. This enables the use of 127/8 for local routing purposes. default FALSE"</p>
<p>This is the equivalent of the following on the command line </p><pre class="fragment">echo "1" &gt; /proc/sys/net/ipv4/conf/&lt;ifaceName&gt;/route_localnet
</pre><p> Or echo "0" &gt; /proc/sys/net/ipv4/conf/&lt;ifaceName&gt;/route_localnet</p>
<p>This is used so we can use iptables to route packets on the bridge interface to local host. The main usage is for connecting specific ports like dns, as to the localhost interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ifaceName</td><td>The name of the interface to set the config on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>true to enable, false to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a3949cb04a9ab5489d4dbcb5e96c501b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3949cb04a9ab5489d4dbcb5e96c501b1">&#9670;&nbsp;</a></span>setLinkAddress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::setLinkAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNlLink.html">NlLink</a> &amp;&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const in_addr_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const in_addr_t&#160;</td>
          <td class="paramname"><em>netmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the ip address and netmask of an interface (IPv4) </p>
<p>This is the equivalent of the following on the command line </p><pre class="fragment">ifconfig &lt;ifaceName&gt; &lt;address&gt; netmask &lt;netmask&gt;
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">link</td><td>Instance of <a class="el" href="classNlLink.html" title="Wrapper around the rtnl_link object.">NlLink</a> (rtnl_link wrapper) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address to set, the netmask will be applied to this before setting on the iface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">netmask</td><td>The netmask to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a528c41cefc07e00a649a464390d34a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528c41cefc07e00a649a464390d34a42">&#9670;&nbsp;</a></span>setLinkAddress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Netlink::setLinkAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNlLink.html">NlLink</a> &amp;&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct in6_addr&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>netmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the ip address and netmask of an interface (IPv6) </p>
<p>This is the equivalent of the following on the command line </p><pre class="fragment">ifconfig &lt;ifaceName&gt; inet6 add &lt;address&gt;/&lt;netmask&gt;
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">link</td><td>Instance of <a class="el" href="classNlLink.html" title="Wrapper around the rtnl_link object.">NlLink</a> (rtnl_link wrapper) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The address to set, the netmask will be applied to this before setting on the iface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">netmask</td><td>The netmask to apply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>rdkPlugins/Networking/include/<a class="el" href="Netlink_8h_source.html">Netlink.h</a></li>
<li>rdkPlugins/Networking/source/Netlink.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
